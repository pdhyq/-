### 双指针分为三种：

> * 普通的指针：多是两个指针往同一个方向移动；
> * 对撞的指针<font color=Red>（多用于有序的情况）</font>：两个指针面对面移动(比如一头一尾往中间移动)；
> * 快慢的指针：慢指针+快指针。（目前遇到的大多数题都是和链表相关的，因为链表无法使用对撞指针无法做到随机读取）

**双指针的核心思想是优化。**
1. 移动元素时（反转...，移动...）
2. 如果遇到多重循环，就要考虑用双指针，双指针可以用来优化最后两个循环。[四数之和II](https://leetcode.cn/problems/4sum-ii/)
3. 双指针我自认为也应该考虑区间，而双指针都是左闭右闭，即两个指针所指向的元素都在考虑范围之内，而且不是指那些存储元素的集合里边的元素区间，毕竟指针移动之后的元素还没进入集合，得先让他加入循环，总而言之，和滑动窗口一样，真正的区间是两个指针之间的区间。（这里主要是因为在做题的时候突然觉得右指针指向的元素还没加入集合怎么能算左闭右闭呢。但其实处理的第一个步骤就是把它加入集合，所以当时有点魔怔，不用太过在意）
4. 删除某些特定元素时
5. 需要前后兼顾两个元素
6. 让右指针一直往前走，不要一步一步的走，然后在这个大循环里边，可能需要一个循环或者不需要将左指针放到合适的位置（滑动窗口，但是我感觉双指针也可以这样）
    [209. 长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/)
```cpp
class Solution
{
public:
    int minSubArrayLen(int target, vector<int> &nums)
    {
        int l = 0, r = 1, sum = nums[0], len = 9999999;
        if (sum >= target)
            return 1;
        while (l < r)
        {
            if(sum < target && r == nums.size())
                break;
            if (sum < target && r < nums.size())
            {
                sum += nums[r++];
            }
            else if (sum >= target)
            {
                len = min(r - l, len);
                sum -= nums[l++];
            }
        }
        if (len != 9999999)
            return len;
        return 0;
    }
};
```
>上边这种写法窗口移动的瞻前顾后，缝缝补补，很不尽人意
下边这种写法就不需要每次移动都要分很多情况，右指针自由移动，左指针自己跟上。
```cpp
class Solution {
public:
    int minSubArrayLen(int s, vector<int>& nums) {
        int n = nums.size();
        if (n == 0) {
            return 0;
        }
        int ans = INT_MAX;
        int start = 0, end = 0;
        int sum = 0;
        while (end < n) {
            sum += nums[end];
            while (sum >= s) {
                ans = min(ans, end - start + 1);
                sum -= nums[start];
                start++;
            }
            end++;
        }
        return ans == INT_MAX ? 0 : ans;
    }
};
```
### 拓展 滑动窗口

滑动窗口是一种基于双指针的一种思想，两个指针指向的元素之间形成一个窗口。

分类：窗口有两类，一种是固定大小类的窗口，一类是大小动态变化的窗口。

#### 应用：

利用滑动窗口获取平滑的数据，如一段连续时间的数据平均值，能够有更好的稳定性，如温度监测。

什么情况可以用滑动窗口来解决实际问题呢？

1. 一般给出的数据结构是数组或者字符串
2. 求取某个子串或者子序列最长最短等最值问题或者求某个目标值时
3. 该问题本身可以通过暴力求解

```cpp
class Solution
{
public:
    int lengthOfLongestSubstring(string s)
    {
        unordered_set<char> a;
        int max = 0;
        int j = 0;
        for (int i = 0; i < s.size(); ++i)
        {
            auto jud = a.insert(s[i]);
            if (!jud.second)
            {
                if (max < a.size())
                    max = a.size();
                while (s[j] != s[i])
                {
                    if (s[j] != s[i])
                        a.erase(s[j++]);
                }//出问题的地方
            }
        }
        return a.size()>max?a.size():max;
    }
};
```

> #### 错误：
> 
> 可以看出左指针移动出了问题，本意是想着不插入当前元素，那把之前重复的元素保留下来就好了就不需要额外插入这个新元素，这样的话左指针指向的位置就会变成指向之前那个没有重复元素，这么一看好像是对的，就像“abcabcbb”，遇到第二个a时，插入失败了，左指针指向了第一个a的位置，下次遇到了b，那就把第一个b之前的元素都移出去，就从上次删除结束的位置开始删就把a删掉了指针指向第一个b。这么一看确实没什么问题，再看遇到重复元素就像“aabbcc”，第一次删除指向第一个a，这个删除指针应该要指向第二个a。不管怎么样都犯了一个错误，那就是把里边定义的set当成了窗口，**但实际上窗口应该是两个指针之间的位置，而不是set中那些元素**，所以两个指针应该随时指着区间的左右边界，而这里我只是把它当作了维护set的工具，可能有点混乱。但是要搞清楚先后，是先要将两个指针指向正确的区间，然后set将这个区间的元素放入自己内部，并且如果发现重复元素之后帮助左指针找到正确的位置，而不是通过左指针的变化找到set正确的内容。

> #### 举例：
> 
> * abcda
>   当前的情况：（abcd）a
>   实际的情况：a（bcda）
>   **仅仅就是这种很小的差别就会导致结果出错**
> * 将abcda结尾加个b：
>   abcdab
>   当前情况：a（bcd）ab
>   实际情况：ab（cdab）
>   就可以看出左右指针指向的区间不一样了，当然这种情况最终结果会是4，但如果是abcdabcde呢？答案就错了。
>   毕竟要修改元素的区间都错了（虽然容器里的元素一样）本来只要删个b结果还把a给删了。

**所以遇到滑动窗口时一定要注意，真正的窗口是两个指针之间的区间，而不是自己定义的那些存储这些元素的容器**

### 拓展 单调队列

单调队列从字面上看，无非就是有某种单调性的队列，没错，这就是所谓的单调队列。 单调队列它分两种，一种是单调递增的，另外一种是单调递减的。
==用单调队列来解决问题，一般都是需要得到当前的某个范围内的最小值或最大值。==

> **举个例子**
> 有  7 6 8 12 9 10 3 七个数字，现在让你找出范围（ i-4，i ） 的最小值。
> 那我们就可以这样模拟一遍。

1. 先初始化{ 0 } （表示i=0时的值）
2. i=1 ->{ 0 } （表示i=1,时，在其范围内最小的值为0）-> 7进队 { 7 } ；
3. i=2->{ 7 }（表示i=2,时，在其范围内最小的值为7）-> 6比7小，7出，6进 { 6 }；
4. i=3-> { 6 } （表示i=3,时，在其范围内最小的值为6）->8比6大，8进  { 6, 8}；
5. i=4->{ 6, 8}（表示i=4,时，在其范围内最小的值为6）-> 12比8大，12进 {6, 8 , 12};
6. i=5-> {6, 8 , 12}（表示i=4,时，在其范围内最小的值为6）-> 9比12小，12out，9比8大，9进 {6，8,  9}；
7. i=6-> {6，8,  9} **但是 单调队列中元素6的下标是2，不在（2, 6],中，故6 out，这就是单调队列的精髓了**。故单调队列为{ 8,9 }（表示i=5,时，在其范围内最小的值为8）->10比9大，10进 最终 单调队列为{ 8，9, 10} ;
8. i=7->{ 8，9, 10}（表示i=6,时，在其范围内最小的值为8）-> 3比单调队列为{ 8，9, 10} 的任意值都小，故全out，最终集合为 { 3 }；

相信大家看完这个例子了解得有些吧，再次重申一遍，单调队列的核心：**得到当前的某个范围内的最小值或最大值。** 要不是这样的话，那还有必要这么麻烦找吗，直接找前面最小的就好了，可事实不是这样，题目是有限制的，规定在某个范围内找。

为什么在步骤7中的单调队列的首个元素不满足条件就只需要删除这一个就可以，下一个元素为什么一定是满足条件的最小值，因为是按照数组元素的顺序入队的，**也就是说数组中第i个元素，在队列的位置一定是<=i的，= i 的情况是前面的元素一个也没有被移除队列，< i 的情况说明前面有的元素被移除去了，因为如果接下来有更小的，不是将它往后移而是直接踢出队列**，总体来说一定是 <= i 的情况。也就是说在第i个步骤之前的i-1个步骤每一步如果他们的最小值不是此区间的，那就扔掉，是此区间的那就说明前边区间的已经全部扔掉了。
通过归纳法就可以证明，第一步（这里的第一步不是上边的那些步骤而是初始化队列之后的第一步，应该是第4或5步）里边的数一定是第一个区间的，第二步中如果最小值是第一个区间的，那就删掉；如果不是，更好，说明只属于第一步的唯一一个已经被出队了（为什么是唯一一个，因为第i步的区间是[i,i+3],第i+1步的区间是[i+1,i+1+3],所以二者中唯一只属于第i步的只有一个 i 而已，**在数组中的顺序a在b前边，那么挨个插入单调队列中，正常来说a会在<=a的地方，b也会在<=b的地方，正如上边所说的那样，如果发现没有a，只能说明a被出队了**）。【说的很混乱，要搞明白，虽然不是什么很重要的东西，但是只有这里有点困惑】
<font size=6>==单调队列中，队列中的元素一般是数组的索引，因为要判断元素区间是否正确。==</font>
```cpp
class Solution
{
public:
    vector<int> maxSlidingWindow(vector<int> &nums, int k)
    {
        deque<int> q;
        vector<int> v;
        for (int i = 0; i < k; ++i)
        {
            while (!q.empty() && nums[q.back()] <= nums[i])
                q.pop_back();
            q.push_back(i);
        }
        v.push_back(nums[q.front()]);
        for (int i = k; i < nums.size(); ++i)
        {
            while (!q.empty() && q.back() <= nums[i])
                q.pop_back();
            q.push_back(i);
            if (i - q.front() >= k)
            {
                q.pop_front();
            }
            v.push_back(nums[q.front()]);
            for (auto it = q.begin(); it != q.end(); ++it)
                cout << nums[*it] << " ";
            cout << endl;
        }
        return v;
    }
};
```
### 单调栈（根据出栈的顺序决定是递增还是递减，如果是出栈元素一个比一个大就是递增，反之递减）
>单调栈:单调栈和单调队列一样，栈中的顺序也是和原数组中的相对顺序一致（由新到旧）。栈顶位置也一定是上个元素。**当前元素的停止位置是之前所有元素中第一个大于它的元素**(单调递增栈)，**但是之前不也有元素被出栈吗？这些出栈的元素没有比它大的吗？因为回到最根本的问题，单调栈中的元素顺序(栈顶->栈尾)也是从新到旧的(入栈顺序)，而单调栈解决的也是返回第一个大于当前元素的元素，也就是离他最近的最新的元素，再说那些被移除的元素就是小于目标元素而被移除的，所以目标元素就是离当前元素最近的满足条件的元素。同样被出栈的元素就是因为它找到位置后后续元素入栈过程中第一次遇到比它大的元素，由此确定了任意一个元素左右第一个比它大的元素。**
<font color=red>单调递增栈确定的是每个元素左右两边第一个大于它的元素，单调递减栈确定的是第一个小于它的元素。
单调递增栈，趋势是递增的，如果进来的元素破坏了递增的整体趋势，就将栈中不满足条件的删掉，删掉的这些都满足小于当前元素的条件，所以最终停留的位置就是第一个大于它的，当下一个元素入栈时，如果大于当前元素，就说明当前元素包括被当前元素删掉的那些元素都理所当然的都小于下一个元素，而如果下一个元素小于当前元素，就找到了第一个大于它的元素，为什么不是之前的那些元素，因为当前元素是离下一个元素最近的，也就是最新的，也就是第一个大于的。（觉得上边写的太混乱了，就写了一遍）
***
>难道按照这个递增栈按照这个思路找不到第一个小于的？比如因为栈顶的元素一定是上一个元素，如果下面来的元素没有除去它，那第一个来的元素不就是他遇到的第一个最小的吗，那如果下面来的元素是第一个大于它的(姑且不考虑等于的情况)它不就被删除了吗，被删除了可以确定当前元素遇到的第一个最小的元素，但是下边如果还有其他要被除去的元素呢，可以弄一个bool……，可以总结一下可以确定最小元素的情况
1.上一个元素大于当前元素不会删除可以确定上一个元素右边界第一个小于的
2.上一个元素被删除，那可以确定当前元素左边界第一个小于的
>
>对应的
>
>如果当前元素小于上一个元素没有删除上一个元素，那当前元素的左边第一个小于的元素如何确定
>
>也就是说只有第i个元素大于第i-1和i+1的元素的时候才能确定第个元素的左右边界，这两个条件缺了任何一个，都会确定不出来
>
>综上，不能确定最小元素。


单调队列和单调栈的关系，单调队列确定的是一个区间内的最大最小值，而单调栈确定的是任意一个元素左右边第一个大于或小于的元素。而且，对于单调递增队列来说，是小的在队首，也就是最早入队的是小的；对于单调递增栈来说，大的在前边，也就是最早入栈的是大的。上边这话没啥用，想表达点东西但是不会表达，直接说结论，单调队列也可以找到一个值的左右边界，单调递增队列，在队尾插入元素，淘汰的是那些大的元素，然后遇到第一个小于当前元素的停下，所以找的是第一个比当前元素小的左右边界，与单调栈相反。但是单调栈不能用来找区间最大最小值，因为单调栈是在一边进出，单调递增栈，进去大的就会把小的淘汰掉也就找不出最小的了</font>
  ##### 单调栈的两种基本思路（以单调递增栈为例）
  1. 记录下自己最后所停留的位置，这是左边第一个大于当前元素的元素。记录下谁把它出栈，这是右边第一个大于它的元素。
  2. 记录下最后一个被出栈的元素的位置记为a，然后将a入栈，将a的高度更改为当前元素的高度。这样就不需要额外记录左边第一个大于它的元素，它所在的位置就是第一个大于的



### 刷题之后的散记
其实双指针和滑动窗口是有些许区别的。滑动窗口一句话就是右指针先出发，左指针视情况追赶右指针。可类比男生暗恋女生，两人都在往前走，但男生总是默默跟着女生走但又不敢超过她。因此，右指针最多遍历一遍数组，左指针也最多遍历一次数组，时间复杂度不超过O(2N)。接下来，如何判断滑动窗口内是否满足题设条件，有两种选择：(1) 要么你遍历这个滑窗，通过遍历来断滑窗是否满足需要O(N), 那么总的时间就退化为O(N^2), (2) 要么你选择字典，用空间换时间，那么判断划窗是否满足条件则需要 O(1)，总时间为O(N).

滑动窗口问题，左右指针的变化很多，但是可以认准一个就是让右指针动，然后让左指针找到它自己的位置
```cpp
for(int right=0;right<n;right++)
{
    if(left和right之间的集合满足条件)
    {
        更新计数器或者其他操作。
        比如求满足题目的最大区间的大小（和），那就可以在这一步更新大小（sum）。
    }
    else
    {
        //不满足条件
        //如果上个满足条件的判断里边不想做那些操作，也可以在这里做，更新大小或者求和（注意如果将更新操作放在这里，一定要在循环之后再接一个更新操作，原因见下）
        将左指针移动，移动到刚好满足条件的边界点。
    }
}
```
滑动窗口特殊情况特别多，比如在某一点之后直到结束一直是满足条件的，而恰好你为了省时间或者想炫技，把所有操作都放在了不满足条件的判断语句中了，那么后续的这些操作都不会进行更新，所以要在循环之后再加一个判断语句。
滑动窗口的区间范围，左闭右闭，是指针的范围没错，但是如果集合里边的范围不是，那么在操作的一开始，一定要更新到和指针的区间一致，才能继续满足左闭右闭



### 最大二叉树

最大二叉树问题，与单调栈的唯一不同就是考虑问题的方式，对于任意一个节点，可以得到他的最近的最大值是哪个，左侧的最大值，那就说明他可以作为该最大值的右节点；相对的，对于右侧的最大值就可以作为该最大值的左节点。这样就会有很多冲突的产生，因为光这么看，很多左右节点都重复了，因为一个节点的左右距离最近的大于它的值会有重复。

这里就是思考方式的不同，更新值的方式变了，以前递增栈是为了找到左右距离最近的大于它的值，现在虽说也是，但是按照上面的思路，是在找一个节点的父节点，所以更新值的方式变了，应该是由父节点去连接子节点。















