[四数之和II](https://leetcode.cn/problems/4sum-ii/)

这题如果暴力解法的话，是一个时间复杂度为$ O(n^4)$的循环，会超时，这时候就可以先用一个哈希表存储下前两个数组的所有和，然后再弄一个二重循环找到后两个数组中是否有满足条件的和，就优化成为两个时间复杂度为$O(n^2)$的循环。

所以如果有的题不会做，只能想到暴力解法的时候，一个就是在之前二分查找的时候提到的，如果能锁定一个范围（包括暴力解法但不仅限于暴力解法，这可以是个通用方法，只要可以锁定范围就可以用），就可以使用二分查找来进行查找到最后的目标值。如果是想这种题锁定不了范围的，那就使用哈希表将循环拆分成小循环。

[三数之和]([15. 三数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/3sum/))

```cpp
class Solution
{
public:
    vector<vector<int>> threeSum(vector<int> &nums)
    {
        vector<vector<int>> ret;
        int n = nums.size();
        sort(nums.begin(),nums.end());
        for(int i=0;i<n;++i)
        {
            if(i>0&&nums[i]==nums[i-1])
                continue;
            if(nums[i]>0)
                break;
            unordered_set<int> s;
            for(int j=i+1;j<n;++j)
            {
                /*下边的去重意思是：首先确定第一个元素，之后是在确定后两个元素的取值，这里犯了一个错误就是，不允许三元组重复，而不是不允许三元组中的元素重复，这里应该注意区分，就像允许0 0 0 这种组合，所以现在应该要解决的是，后边两个元素组合没有重复，这里的j，不仅仅代表第二个元素，而是在有匹配元素时，他是第三个元素，没有匹配时，作为第二个元素加入集合，要保持这种组合不变，遇到两个元素都不相同的情况下好说，直接判断即可，如果两个元素相同，并且这两个元素恰好满足条件，那么在下次的循环中这个元素如果还是和前面两个相等，就冗余了，而且一旦重复的太多，就像0 0 0 0 ，那么就会导致重复单元组，所以直接继续就可以。综上：后边两个元素，只有当遇到多于2个重复元素的时候才会跳过此次循环，其余的情况都可以进行正常的判断。*/
                if(j>i+2&&nums[j]==nums[j-1]&&nums[j]==nums[j-2])
                    continue;
                if(s.find(0-nums[j]-nums[i])!=s.end())
                {
                    ret.push_back({nums[i],nums[j],-nums[i]-nums[j]});
                    s.erase(-nums[i]-nums[j]);
                }
                else
                    s.insert(nums[j]);
            }
        }
        return ret;
    }
};
```

本题的难点就在于三元组的去重，区分三元组重复和元素重复。这题的这种做法是超时的。只是说一下这种去重的思路。第一个元素确定下来，然后找对应的第二三个元素，所以只需要去重第二三个元素，当然也可以继续运用递归的思想，再定下第二个元素，去找第三个满足条件的元素，但是这种做法，其实就是暴力枚举每一种可能，不可取。那就只能同时去找第二三个元素。当前遍历到的元素，如果之前没有让他为零的元素，那就直接进入集合就好，然后遇到一个满座条件的元素，那就直接加入答案就好了。去重条件就是，只要不是连着两个以上的元素，在遍历时，都会进行一次判断，两个以上的元素就需要跳过，因为只要两个相等的元素遍历过去就没了，再多了会重复。

说的太模糊了，举个例子，目前第一个元素是-2，然后后边的是0 -1 1 1 1 1 2 2 2 ；遍历到0，直接入集合，遍历到-1，同样入集合，遍历到1入集合，下一个1遍历到，这时候发现集合有一个1，刚刚好满足条件，这就是所说的，分清楚三元组重复和元素重复，不能盲目的将重复的元素略过。然后将1删除集合，因为一个元素就对应一个答案，所以留着也没什么用处，然后遇到下一个1，如果这时候还不跳过，那么就会把1加入集合，然后与后边的1又会组成答案。所以去重的唯一条件就是不能有连续两个以上的重复元素。