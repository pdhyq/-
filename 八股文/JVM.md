# 内存区域

[Java内存区域(运行时数据区域) 和 内存模型(JMM) - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/434541309)

[JVM系列(二) - JVM内存区域详解 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/43279292)

[8张图 让你明白 Java内存区域 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/297001119)

## 线程私有

- 程序计数器
- 虚拟机栈
- 本地方法栈

### 程序计数器

字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令

为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。

### 虚拟机栈

方法调用的数据需要通过栈进行传递，每一次方法调用都会有一个对应的栈帧被压入栈中，每一个方法调用结束后，都会有一个栈帧被弹出。

栈由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法返回地址。和数据结构上的栈类似，两者都是先进后出的数据结构，只支持出栈和入栈两种操作。

* **局部变量表**：主要存放了编译期可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。
* **操作数栈**：主要作为方法调用的中转站使用，用于存放方法执行过程中产生的中间计算结果。另外，计算过程中产生的临时变量也会放在操作数栈中。
* **动态链接** 主要服务一个方法需要调用其他方法的场景。Class 文件的常量池里保存有大量的符号引用比如方法引用的符号引用。当一个方法要调用其他方法，需要将常量池中指向方法的符号引用转化为其在内存地址中的直接引用。动态链接的作用就是为了将符号引用转换为调用方法的直接引用，这个过程也被称为 **动态连接**
* **方法返回地址：存放调用该方法的pc寄存器的值。**一个方法的结束,有两种方式：正常执行完成和出现未处理的异常,非正常退出。无论通过哪种方式退出,在方法退出后都返回到该方法被调用的位置。**方法正常退出时,调用者的pc计数器的值作为返回地址,即调用该方法的指令的下一条指令的地址**。而通过异常退出的,返回地址是要通过异常表来确定,栈帧中一般不会保存这部分信息。**本质上方法的退出就是当前栈帧出栈的过程。此时,需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等**,让调用者方法继续执行下去。正常完成出口和异常完成出口的区别在于：**通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。**

[深入解析JVM之虚拟机栈(面试必备) - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/423364303)

Java 方法有两种返回方式，一种是 return 语句正常返回，一种是抛出异常。不管哪种返回方式，都会导致栈帧被弹出。也就是说， **栈帧随着方法调用而创建，随着方法结束而销毁。无论方法正常完成还是异常完成都算作方法结束。**



### 本地方法栈

**虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务**



## 线程共享

- 堆
- 方法区
- 直接内存 (非运行时数据区的一部分)

### 堆

**此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。**

Java 世界中“几乎”所有的对象都在堆中分配，但是，随着 JIT 编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。从 JDK 1.7 开始已经默认开启逃逸分析，如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存

Java 堆是垃圾收集器管理的主要区域，因此也被称作 **GC 堆（Garbage Collected Heap）**。从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代；再细致一点有：Eden、Survivor、Old 等空间。进一步划分的目的是更好地回收内存，或者更快地分配内存。

在 JDK 7 版本及 JDK 7 版本之前，堆内存被通常分为下面三部分：

1. 新生代内存(Young Generation)
2. 老生代(Old Generation)
3. 永久代(Permanent Generation)

大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 S0 或者 S1，并且对象的年龄还会加 1(Eden 区->Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 `-XX:MaxTenuringThreshold` 来设置。

> **🐛 修正（参见：[issue552open in new window](https://github.com/Snailclimb/JavaGuide/issues/552)）**：“Hotspot 遍历所有对象时，按照年龄从小到大对其所占用的大小进行累加，当累加到某个年龄时，所累加的大小超过了 Survivor 区的一半，则取这个年龄和 `MaxTenuringThreshold` 中更小的一个值，作为新的晋升年龄阈值”。



### 方法区

[JVM方法区详解-CSDN博客](https://blog.csdn.net/web18296061989/article/details/123759627?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-4-123759627-blog-119615972.235^v43^pc_blog_bottom_relevance_base8&spm=1001.2101.3001.4242.3&utm_relevant_index=7)

[方法区（Method Area）详解-CSDN博客](https://blog.csdn.net/qq_43684005/article/details/119615972)

>StringTable为什么要调整位置
> jdk7中将StringTable放到了堆空间中。因为永久代的回收效率很低，在full gc的时候才会触发。而full gc是老年代的空间不足、永久代不足时才会触发。
>
>这就导致StringTable回收效率不高。而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆里，能及时回收内存。
>

方法区属于是 JVM 运行时数据区域的一块逻辑区域，是各个线程共享的内存区域

当虚拟机要使用一个类时，它需要读取并解析 Class 文件获取相关信息，再将信息存入到方法区。方法区会存储已被虚拟机加载的 **类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据**。

《Java 虚拟机规范》只是规定了有方法区这么个概念和它的作用，方法区到底要如何实现那就是虚拟机自己要考虑的事情了。也就是说，在不同的虚拟机实现上，方法区的实现是不同的。

**方法区和永久代以及元空间是什么关系呢？** 方法区是一种思想，永久代和元空间都是其实现

[这一次，彻底弄懂java中的常量池 - 掘金 (juejin.cn) 仔细看看](https://juejin.cn/post/6854573216824819719)

>这里需要强调一下**不同的类共用一个运行时常量池**，同时在进入运行时常量池的过程中，多个class文件中常量池相同的字符串，多个class文件中常量池中相同的字符串只会存在一份在运行时常量池，这也是一种优化。

[【面试题精讲】JVM-方法区-运行时常量池-腾讯云开发者社区-腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/2353318)

[Java中几种常量池的区分 // Emanuel's Notes (tangxman.github.io)](https://tangxman.github.io/2015/07/27/the-difference-of-java-string-pool/)

[Java方法区、永久代、元空间、常量池详解_java永久地址-CSDN博客](https://blog.csdn.net/u011635492/article/details/81046174)

### 运行时常量池

[JVM常量池最全详解-常量池/运行时常量池/字符串常量池/基本类型常量池，看这一篇就够了_java如何查看字符串是否在常量池-CSDN博客](https://blog.csdn.net/weixin_42679575/article/details/128021153)

[运行时常量池和字符串常量池的区别-CSDN博客](https://blog.csdn.net/qq_44752641/article/details/119906982)



**字符串常量池** 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建



动态链接的内容

> [浅析 JVM 中的符号引用与直接引用_符号引用和直接引用存放在哪-CSDN博客](https://blog.csdn.net/luzhensmart/article/details/82627897)
>
> [详解“符号引用转直接引用” | lienhui68の博客 (gitee.io)](https://lienhui68.gitee.io/2020/工作/200_编程语言/java/jvm/详解“符号引用转直接引用”/#常量池中的元素都要转吗)
>
> [谈谈对Java中符号引用和引用的理解 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/657320730)
>
> [(52 封私信 / 80 条消息) 如何理解JVM栈帧中的动态链接？ - 知乎 (zhihu.com)](https://www.zhihu.com/question/347395101)
>
> [(52 封私信 / 80 条消息) JVM为什么说栈帧里面存放着动态连接，而不是存着方法的直接引用？ - 知乎 (zhihu.com)](https://www.zhihu.com/question/527765981)

就记住，程序中写的所有的变量，使用的时候，反编译之后都是符号引用，都是在解析的时候转化为直接引用。



### 直接内存

- 属于操作系统，常见于NIO操作时，用于数据缓冲区
- 分配回收成本较高，但读写性能高
- 不受JVM内存回收管理

直接内存是操作系统和Java代码**都可以访问的一块区域**，无需将代码从系统内存复制到Java堆内存，从而提高了效率





# 垃圾回收

[JVM: GC过程总结(minor GC 和 Full GC)-CSDN博客](https://blog.csdn.net/weixin_42615068/article/details/102813947)

[⭐图解 JVM GC 过程-腾讯云开发者社区-腾讯云 (tencent.com) 仔细看看](https://cloud.tencent.com/developer/article/1336605)

[⭐【Java面试题汇总】JVM篇（2023版）_jvm面试题-CSDN博客](https://blog.csdn.net/qq_40991313/article/details/130232389)

>* 首先，任何新对象都分配到 eden 空间。两个幸存者空间开始时都是空的。
>* 当 eden 空间填满时，将触发一个Minor GC(年轻代的垃圾回收，也称为Young GC)，删除所有未引用的对象，大对象（需要大量连续内存空间的Java对象，如那种很长的字符串）直接进入老年代。
>* 所有被引用的对象作为存活对象，将移动到第一个幸存者空间S0，并标记年龄为1，即经历过一次Minor GC。之后每经过一次Minor GC，年龄+1。GC分代年龄存储在对象头的Mark Word里。
>* 当 eden 空间再次被填满时，会执行第二次Minor GC，将Eden和S0区中所有垃圾对象清除，并将存活对象复制到S1并年龄加1，此时S0变为空。
>* 如此反复在S0和S1之间切换几次之后，还存活的年龄等于15的对象（JDK8默认15，JDK9默认7，-XX:InitialTenuringThreshold=7）在下一次Minor GC时将放到老年代中。 
>* 当老年代满了时会触发Major GC（也称为Full GC），Major GC 清理整个堆 – 包括年轻代和老年代。



[【JVM】垃圾回收_jvm垃圾回收可达性详解-CSDN博客](https://xppll.blog.csdn.net/article/details/120824468)

Java 堆是垃圾收集器管理的主要区域，因此也被称作 **GC 堆**

现在收集器基本都采用分代垃圾收集算法，所以 Java 堆被划分为了几个不同的区域，这样我们就可以根据各个区域的特点选择合适的垃圾收集算法。

将堆内存分为**新生代**和**老年代**，新生代有划分为**伊甸园**，**幸存区To**，**幸存区From**。

![img](https://img-blog.csdnimg.cn/img_convert/352c08f943bc534b07c8c30c74efc7da.png)

​	



## 内存分配和回收原则

对象优先在 Eden 区分配，大多数情况下，对象在新生代中 Eden 区分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。

大对象直接进入老年代，这是由虚拟机动态决定的，它与具体使用的垃圾回收器和相关参数有关。大对象直接进入老年代是一种优化策略，旨在避免将大对象放入新生代，从而减少新生代的垃圾回收频率和成本。

长期存活的对象直接进入老年代，虚拟机给每个对象一个对象年龄（Age）计数器，大部分情况，对象都会首先在 Eden 区域分配。如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间（s0 或者 s1）中，并将对象年龄设为 1(Eden 区->Survivor 区后对象的初始年龄变为 1)。对象在 Survivor 中每熬过一次 MinorGC,年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。



**主要进行gc的区域：**

针对 HotSpot VM 的实现，它里面的 GC 其实准确分类只有两大种：

部分收集 (Partial GC)：

- 新生代收集（Minor GC / Young GC）：只对新生代进行垃圾收集；
- 老年代收集（Major GC / Old GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；
- 混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。

整堆收集 (Full GC)：收集整个 Java 堆和方法区。



**空间担保**

[一篇文章带你搞懂空间分配担保原则！ - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/624593662)

> 如果YougGC时新生代有大量对象存货下来，而survivor区放不下了，这时必须转移到老年代中，但这时发现老年代也放不下这些对象了，那怎么处理呢？其实JVM有一个老年代空间分配担保机制来保证对象能够进入老年代。
>
> 在执行每次YoungGC之前，JVM会先检查老年代最大可用连续空间是否大于新生代所有对象的总大小。因为在极端情况下，可能新生代YoungGC后，所有对象都存活下来了，而survivor区又放不下，那可能所有对象都要进入老年代了。
>
> 这个时候如果老年代的可用空间是大于新生代所有对象的总大小的，那就可以放心进行YoungGC。但如果老年代的内存大小是小于新生代对象总大小的，那就可能老年代空间不够放入新生代所有存活对象，这个时候JVM就会先检查-XX：HandlePromotionFailure参数是否允许担保失败。
>
> 如果允许，就会判断老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次YoungGC，尽管这次YoungGC是有风险的。但是如果小于，或者-XX：HandlePromotionFailure参数不允许担保失败，这时就会进行一次Full GC。



## 死亡对象判断方法

### 引用计数

给对象中添加一个引用计数器：

- 每当有一个地方引用它，计数器就加 1；
- 当引用失效，计数器就减 1；
- 任何时候计数器为 0 的对象就是不可能再被使用的。

**这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间循环引用的问题。**

![对象之间循环引用](https://oss.javaguide.cn/github/javaguide/java/jvm/object-circular-reference.png)

### 可达性分析算法

这个算法的基本思想就是通过一系列的称为 **“GC Roots”** 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收。

[【Java 虚拟机原理】垃圾回收算法 ( 可达性分析算法 | GC Root 示例 | GC 回收前的两次标记 | finalize 方法示例 )-腾讯云开发者社区-腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/2251024)

[【Java面试题汇总】JVM篇（2023版）_jvm面试题-CSDN博客](https://blog.csdn.net/qq_40991313/article/details/130232389)

非可达对象被回收需要两次标记：

第一次标记后筛选非可达对象：第一次被标记后，会进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法，也就是是否有机会自救。假如对象没有覆盖或者已被JVM调用过finalize()方法，也就是说不想自救或已自救过，那么此对象需要被回收；假如对象覆盖并没被JVM调用过finalize()方法，该对象将会被放置在一个名为F-Queue的队列之中，并在稍后由一条由虚拟机自动建立的、低调度优先级的Finalizer线程去执行它们的finalize()方法。
第二次标记F-Queue里的未自救对象：稍后，收集器将对F-Queue中的对象进行第二次小规模的标记。如果对象要在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己（this）赋值给某个引用类型的类变量或者对象的成员变量，那在第二次标记时它将被移出“即将回收”的F-Queue。如果对象这时候还没有逃脱，那基本上它就真的要被回收了。

**哪些对象可以作为 GC Roots 呢？**

下面的文章有时间看看：

> [深入理解JVM垃圾回收机制 - GC Roots枚举 - 腾讯云开发者社区-腾讯云 (tencent.com)](https://cloud.tencent.com/developer/news/688469)
>
> >GC Roots 作为 Tracing GC 的起点，其必须是一组活跃的引用。固定可作为 GC Roots 的对象主要在全局的引用 ( 例如常量或类静态属性 ) 与执行上下文 ( 例如栈桢中的本地变量表 ) 中。简单来说就是，**GC Roots 中包含了所有无须跟踪引用就可以得到的对象。**
>
> [闲谈JVM（八）：深入理解JVM GC Roots_mod union table谁来维护的-CSDN博客](https://blog.csdn.net/wtopps/article/details/109186517)
>
> > gc roots是一组引用，并非对象，就是更严谨的说法而已
> >
> > 执行GC操作的根本思路就是：给定一个集合的引用作为根出发，通过引用关系遍历对象图，能被遍历到的（可到达的）对象就被判定为存活，其余对象（也就是没有被遍历到的）就自然被判定为死亡。
>
> 
>
> [(52 封私信 / 80 条消息) java的gc为什么要分代？ - 知乎 (zhihu.com)，可以看看R大是怎么说的](https://www.zhihu.com/question/53613423/answer/135743258)
>
> [(52 封私信 / 80 条消息) Java中的GCRoots到底有哪些?年轻代gc和老年代gc的GCRoots是如何区分的？有兴趣看看](https://www.zhihu.com/question/389362829)

- 虚拟机栈(栈帧中的局部变量表)中引用的对象
- 本地方法栈(Native 方法)中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 所有被同步锁持有的对象
- JNI（Java Native Interface）引用的对象

### 引用类型

[谈谈强引用、软引用、弱引用、虚引用、引用队列、WeakHashMap_虚引用map-CSDN博客](https://blog.csdn.net/m0_60907200/article/details/123776701?ops_request_misc=&request_id=&biz_id=102&utm_term=强引用和弱引用&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-2-123776701.nonecase&spm=1018.2226.3001.4187)



### 如何判断一个常量是废弃常量？

假如在字符串常量池中存在字符串 "abc"，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 "abc" 就是废弃常量，如果这时发生内存回收的话而且有必要的话，"abc" 就会被系统清理出常量池了。



### 如何判断一个类是无用的类？

方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？

判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面 3 个条件才能算是 **“无用的类”**：

- 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。
- 加载该类的 `ClassLoader` 已经被回收。
- 该类对应的 `java.lang.Class` 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。



## 垃圾收集算法

[【Java面试题汇总】JVM篇（2023版）_jvm面试题-CSDN博客](https://blog.csdn.net/qq_40991313/article/details/130232389)

标记清除算法、标记复制算法、标记整理算法。

### 标记-清除算法

* 标记、清除：当堆中有效内存空间被耗尽时，会STW（stop the world，暂停其他所有工作线程），然后先标记，再清除。

* 标记：可达性分析法，从GC Roots开始遍历，找到可达对象，并在对象头中进行标记。
* 清除：堆内存内从头到尾进行线性遍历，“清除”非可达对象。注意清除并不是真的置空，垃圾还在原来的位置。实际是把垃圾对象的地址维护在空闲列表，对象实例化的申请内存阶段会通过空闲列表找到合适大小的空闲内存分配给新对象。
* 优点：简单
* 缺点：
  * 效率不高：需要可达性遍历和线性遍历，效率差。
  * STW导致用户体验差：GC时需要暂停其他所有工作线程，用户体验差。
  * 有内存碎片，要维护空闲列表：回收垃圾对象后没有整理，导致堆中出现一块块不连续的内存碎片。

* 适用场景：适合小型应用程序，内存空间不大的情况。应用程序越大越不适用这种回收算法。



### 标记-复制算法

* 标记、复制、清除：将内存空间分为两块，每次只使用一块。在进行垃圾回收时，先可达性分析法标记可达对象，然后将可达对象复制到没有被使用的那个内存块中，最后再清除当前内存块中的所有对象。后续再按同样的流程来回复制和清除。
* 优点：
  * 垃圾多时效率高：只需可达性遍历，效率很高。
  * 无内存碎片：因为有移动操作，所以内存规整。
* 缺点：
  * 内存利用率低，浪费内存：始终有一半以上的空闲内存。
  * 需要调整引用地址：可达对象移动后，内存地址发生了变化，需要调整所有引用，指向移动后的地址。
  * 垃圾少时效率相对差，但还是比其他算法强：如果可达对象比较多，垃圾对象比较少，那么复制算法的效率就会比较低。只为了一点垃圾而移动所有对象未免有些小题大做。所以垃圾对象多的情况下，复制算法比较适合。
* 适用场景：适合垃圾对象多，可达对象少的情况，这样复制耗时短。非常适合新生代的垃圾回收，因为新生代要频繁地把可达对象从伊甸园区移动到幸存区，而且是新生代满了适合再Minor GC，垃圾对象占比高，所以回收性价比非常高，一次通常可以回收70-90%的内存空间，现在的商业虚拟机都是用这种GC算法回收新生代。



### 标记-整理算法

* 标记、整理、清除：首先可达性分析法标记可达对象，然后将可达对象按顺序整理到内存的一端，最后清理边界外的垃圾对象。相当于内存碎片优化版的标记清楚算法，不用维护空闲列表。
* 优点：
  * 无内存碎片：内存规整。
  * 内存利用率最高：内存既规整又不用浪费一般空间。
* 缺点：
  * 效率最低：效率比其他两种算法都低
  * 需要调整引用地址：可达对象移动后，内存地址发生了变化，需要调整所有引用，指向移动后的地址
  * STW导致用户体验差：移动时需要暂停其他所有工作线程，用户体验差。

![img](https://img-blog.csdnimg.cn/2a57767fc8814dcd8da05743fa8aba05.png)

### 分代收集算法

将堆分为新生代、老年代不同生命周期的对象放在不同的代，采用不同的收集算法，以提高回收效率。

比如在新生代中，每次收集都会有大量对象死去，所以可以选择”标记-复制“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。



## 垃圾收集器

[JVM基础\]-- 垃圾回收器_jvm垃圾回收器-CSDN博客](https://blog.csdn.net/xiaoai1994/article/details/109644578)

七个垃圾回收器

serial串行收集器：新生代

serial old串行收集器：老年代

ParNew：新生代

CMS：老年代

parallel并行收集器：新生代

parallel old并行收集器：老年代

G1



[标记-清除算法_标记清除算法-CSDN博客](https://blog.csdn.net/chengqiuming/article/details/119058929)

[(52 封私信 / 80 条消息) Java 垃圾收集中标记-清除法，是被标记的对象被清理？还是未被标记的对象被清理？ - 知乎 (zhihu.com)](https://www.zhihu.com/question/412994176)

标记的是被引用的对象，然后遍历堆内存，如果发现一个对象是没有被标记的就清除



[深入理解 JVM 的垃圾收集器：CMS、G1、ZGC | 二哥的Java进阶之路 (javabetter.cn)](https://javabetter.cn/jvm/gc-collector.html#zgc)

### CMS（分代垃圾回收器）

[终于把CMS垃圾收集器搞懂了~ - 掘金 (juejin.cn)](https://juejin.cn/post/7023935314703941663#heading-0)



[CMS与三色标记算法 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/340530051)

> 由此可见，并发标记阶段和并发清理阶段确实都会产生浮动垃圾

[JVM之CMS垃圾收集器详解_cms垃圾回收器过程-CSDN博客](https://blog.csdn.net/jbjmh/article/details/136356892)

[CMS垃圾回收器细节思考与补充-腾讯云开发者社区-腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/1903499)

[深入解析CMS垃圾回收器-腾讯云开发者社区-腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/2318989?areaId=106001)

>重新标记：重新扫描堆中的对象，进行可达性分析,标记活着的对象。这个阶段扫描的目标是：新生代的对象 + Gc Roots + 前面被标记为dirty的card对应的老年代对象。如果预清理的工作没做好，这一步扫描新生代的时候就会花很多时间，导致这个阶段的停顿时间过长。这个过程是多线程的。
>
>对于其中的card，看看下面两个
>
>[不会还有人以为cms回收器只有4个阶段吧 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/150696908)
>
>[Card Table 卡表_tablecard-CSDN博客](https://blog.csdn.net/yueyazhishang/article/details/105481951#:~:text=JVM虚拟机用了一个叫做CardTable（卡表）的数据结构来标记年轻代的某一块内存区域中对象是否持有新生代对象的引用，卡表的数量取决于老年代的代销和每张卡对应的内存大小，每张卡在卡表中对应一个比特位，当老年代中某个对象持有了新生代对象的引用时，JVM就会把这个对象的Card所在的位置标记为dirty,(bit位设置为1)，这样在Minor GC时，就不需要扫描整个老年代，而是扫描Card中dirty对应的那些区域。)



[为什么CMS两次标记时要 stop the world（阿里面试）_cms算法 stop the world-CSDN博客](https://blog.csdn.net/fhy569039351/article/details/83960709)

[为什么CMS两次标记时要 STW(stop the world)_牛客博客 (nowcoder.net)](https://blog.nowcoder.net/n/4a4891db96fa453ba659b808da35140f)

[【八股细文】说说CMS回收过程，为啥初始标记和重新标记需要STW，而并发标记不需要？_cms重新标记的作用-CSDN博客](https://blog.csdn.net/Z70769691/article/details/136424547)

>初始标记（Initial Mark）和重新标记（Remark）阶段需要 Stop-The-World（STW） 操作，而并发标记（Concurrent Mark）阶段不需要的主要原因是为了减少对应用程序的影响，提高系统的吞吐量和响应性能。
>
>1. **初始标记阶段（Initial Mark）**：在这个阶段，GC 首先标记出根对象直接引用的对象，以确定哪些对象是存活的。由于需要遍历根对象直接引用的对象，为了确保标记的准确性，需要暂停整个应用程序的执行（STW），以防止在标记过程中对象发生变化。
>2. **并发标记阶段（Concurrent Mark）**：在这个阶段，GC 在不影响应用程序执行的情况下，与应用程序并发执行，继续标记所有可达对象。因为此时应用程序可以继续运行，所以不需要 STW 操作。
>3. **重新标记阶段（Remark）**：在并发标记阶段结束后，应用程序会被暂停（STW），以处理在并发标记期间有变化的对象，确保标记的准确性。重新标记阶段需要对并发标记阶段的增量标记结果进行验证和修正。
>
>总的来说，初始标记和重新标记需要 STW 是为了保证标记的准确性和一致性，而并发标记阶段不需要 STW 是为了尽量减少对应用程序的影响，提高垃圾回收效率。

从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：**并发收集、低停顿**。但是它有下面三个明显的缺点：

- **对 CPU 资源敏感；**
- **无法处理浮动垃圾；**
- **它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。**



### G1（分区垃圾回收器）

**G1 (Garbage First) 垃圾收集器**，是**关注最小时延**的垃圾回收器，也**同样适合大尺寸堆内存的垃圾收集**

有时间琢磨下面的文章

>[JVM工作原理与实战(二十七)：堆的垃圾回收-G1垃圾回收器-CSDN博客](https://blog.csdn.net/jiangyq_/article/details/135839716)
>
>[JVM工作原理与实战(三十九)：G1垃圾回收器原理-CSDN博客](https://blog.csdn.net/jiangyq_/article/details/136092317)
>
>[深入JVM：详解G1垃圾回收器原理_g1垃圾回收器卡表结构-CSDN博客](https://blog.csdn.net/mm1274889792/article/details/139030273)
>
>> 在执行Young GC过程中，G1垃圾回收器会记录每次回收时每个Eden区和Survivor区的详细耗时数据。这些数据为下次回收提供了宝贵的参考，帮助G1更精确地计算出在给定的最大暂停时间内可以回收的Region数量。
>
>[深度学习与总结JVM专辑（三）：垃圾回收器—G1（图文+代码）_g1垃圾回收器-CSDN博客](https://blog.csdn.net/qq_45852626/article/details/127968283)
>
>[一文搞懂G1垃圾回收器_g1垃圾回收器详解-CSDN博客](https://blog.csdn.net/xueyushenzhou/article/details/128507344)



# 类文件结构

```java
ClassFile {
    u4             magic; //Class 文件的标志
    u2             minor_version;//Class 的小版本号
    u2             major_version;//Class 的大版本号
    u2             constant_pool_count;//常量池的数量
    cp_info        constant_pool[constant_pool_count-1];//常量池
    u2             access_flags;//Class 的访问标记
    u2             this_class;//当前类
    u2             super_class;//父类
    u2             interfaces_count;//接口数量
    u2             interfaces[interfaces_count];//一个类可以实现多个接口
    u2             fields_count;//字段数量
    field_info     fields[fields_count];//一个类可以有多个字段
    u2             methods_count;//方法数量
    method_info    methods[methods_count];//一个类可以有个多个方法
    u2             attributes_count;//此类的属性表中的属性数
    attribute_info attributes[attributes_count];//属性表集合
}
```

常量池：

constant_pool_count:代表了是接下来常量项的数量。

[Java Class类文件结构_java class结构-CSDN博客](https://blog.csdn.net/qq_40401156/article/details/109364078)

[Java字节码结构剖析二：字段表 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/50495538)

>*ACC_SUPER 标志用于确定该 Class 文件里面的 invokespecial 指令使用的是哪一种执行语义。目前 Java 虚拟机的编译器都应当设置这个标志。ACC_SUPER 标记是为了向后兼容旧编译器编译的 Class 文件而存在的，在 JDK1.0.2 版本以前的编译器产生的 Class 文件中，access_flag 里面没有 ACC_SUPER 标志。同时，JDK1.0.2 前的 Java 虚拟机遇到 ACC_SUPER 标记会自动忽略它。*



SDP包含了更广泛的内容，它除了列出具体的计划要素外，还可能包括项目的背景介绍、项目目标、沟通计划、变更管理等其他方面的信息。

课本中的计划提供了详细的计划和执行细节，是在SDP的框架下制定的，用于指导项目的具体实施和管理。

因此，可以说SDP是一个更高层次的计划文档，而上述列出的计划是SDP中的具体计划要素。



# 类加载

[JVM类加载过程-CSDN博客](https://blog.csdn.net/zhaocuit/article/details/93038538)

>加载（loading）阶段，java虚拟机规范中没有进行约束，但初始化阶段，java虚拟机严格规定了有且只有如下5种情况必须立即进行初始化（初始化前，必须经过加载、验证、准备阶段）

[第二十章_类的加载过程详解 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/268637051)

[java - JVM类加载机制详解，建议看这一篇就够了，深入浅出总结的十分详细！ - 架构人生 - SegmentFault 思否](https://segmentfault.com/a/1190000038319891#item-14)

[JVM | 基于类加载的一次完全实践-腾讯云开发者社区-腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/2334451)

[JAVA系列之类加载机制详解_自定义类加载器的应用场景-CSDN博客](https://blog.csdn.net/sloveb123/article/details/127877968?ops_request_misc=&request_id=&biz_id=102&utm_term=类加载&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-2-127877968.nonecase&spm=1018.2226.3001.4187)

>初始化
>为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。初始化阶段是执行类构造器<client>()方法的过程。
>
><client>()方法是由编译器自动收集类中的所有类变量赋值动作和静态语句static{}块中的语句合并产生的，编译器收集的顺序是由语句在源文件出现的顺序所决定的。静态语句块中只能访问到定义在静态语句块之前的变量，定义在之后的变量可以赋值，但不能访问。

[类的加载过程详解之过程三：Initialization（初始化）阶段_类的initialize-CSDN博客](https://blog.csdn.net/Weixiaohuai/article/details/120047803)

>**初始化阶段，简言之，为类的静态变量赋予正确的初始值。**
>
>
>
>初始化阶段的重要工作是执行类的初始化方法：<clinit>()方法。
>
>该方法仅能由Java编译器生成并由JVM调用，程序开发者无法自定义一个同名的方法，更无法直接在Java程序中调用该方法，虽然该方法也是由字节码指令所组成。
>**它是由类静态成员的赋值语句以及static语句块合并产生的**。 
>
>Java编译器并不会为所有的类都产生<clinit>()初始化方法。哪些类在编译为字节码后，字节码文件中将不会包含<clinit>()方法？
>
>一个类中并没有声明任何的类变量，也没有静态代码块时；
>一个类中声明类变量，但是没有明确使用类变量的初始化语句以及静态代码块来执行初始化操作时；
>一个类中包含static final修饰的基本数据类型的字段，这些类字段初始化语句采用编译时常量表达式；

[Java类加载机制 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/25228545)

>类加载机制指的是将这些.class文件中的二进制数据读入到内存中，并对数据进行校验，解析和初始化。最终，每一个类都会在方法区保存一份它的**元数据**，在堆中创建一个与之对应的Class对象。
>
>加载和初始化，是类生命周期的两个阶段。
>
>对于什么时候加载，Java虚拟机规范中并没有约束，各个虚拟机都可以按自身需要来自由实现。但绝大多数情况下，都遵循“什么时候初始化”来进行加载。
>
>什么时候初始化？Java虚拟机规范有明确规定，当符合以下条件时（包括但不限于），虚拟机内存中没有找到对应类型信息，则必须对类进行“初始化”操作：
>
>- 使用new实例化对象时、读取或者设置一个类的静态字段或方法时
>- 反射调用时，例如 Class.forName("com.xxx.MyTest")
>- 初始化一个类的子类，会首先初始化子类的父类
>- Java虚拟机启动时标明的启动类
>- JDK8 之后，接口中存在default方法，这个接口的实现类初始化时，接口会其之前进行初始化



加载时机：JVM 启动的时候，并不会一次性加载所有的类，而是根据需要去动态加载。也就是说，大部分类在具体用到的时候才会去加载，这样对内存更加友好。（javaguide）

初始化时机：只有主动去使用类才会初始化类(javaguide)

[类加载、初始化的过程（包括static成员对象）_初始化加载是什么意思-CSDN博客](https://blog.csdn.net/weixin_43751710/article/details/104167091#:~:text=1、加载、初始化的含义 1 类加载，就是查找字节码，从字节码中创建一个class对象（由类加载器执行）,2 链接，就是验证类中的字节码，为静态域分配存储空间 3 初始化，就是为静态成员初始化及静态代码块执行（通俗来说就是赋值）的过程)

[java类在什么时候加载和初始化_类是为什么被加载-CSDN博客](https://blog.csdn.net/Geek_sun/article/details/83052637)



# 类加载器

看这个章节就记住重点是确保同一个类只被加载一次

**类加载器的主要作用就是加载 Java 类的字节码（ `.class` 文件）到 JVM 中（在内存中生成一个代表该类的 `Class` 对象）。**

JVM 启动的时候，并不会一次性加载所有的类，而是根据需要去动态加载。也就是说，大部分类在具体用到的时候才会去加载，这样对内存更加友好。

[深入理解Java类加载器(ClassLoader)_java classloader-CSDN博客](https://blog.csdn.net/javazejian/article/details/73413292)

[自定义类加载器的父类为什么是AppClassLoader?-CSDN博客](https://blog.csdn.net/CPLASF_/article/details/120403702)

[聊聊SPI机制以及为什么说SPI破坏了双亲委派模型_spi违背双亲委派模型吗-CSDN博客](https://blog.csdn.net/foxException/article/details/109008206)

重点是可见性。
