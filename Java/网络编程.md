# xml

**它是是一种数据表示格式，可以用于自定义数据格式。**

<img src="C:\Users\痞妖\AppData\Roaming\Typora\typora-user-images\image-20230701002452032.png" alt="image-20230701002452032" style="zoom:50%;" />

* 标签由一对尖括号和合法标识符组成: <name></name>，必须存在一个根标签，有且只能有一个。

* 标签必须成对出现，有开始，有结束: <name></name>

* 特殊的标签可以不成对，但是必须有结束标记，如:<br/>

* 标签中可以定义属性，属性和标签名空格隔开,属性值必须用引号引起来<student id = “1"></name>

* 标签需要正确的嵌套

XML文件中可以定义注释信息：<!-- 注释内容 -->

**XML文件中可以存在以下特殊字符**(因为这些就像是C++中的int，直接写会出事)

```xml
	&lt;    <  小于
    &gt;    >  大于
    &amp;   &  和号
    &apos;  '  单引号
    &quot;  "  引号
```

XML文件中可以存在CDATA区: <![CDATA[  …内容… ]]>

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!-- 注释 以上抬头声明必须存在，且在第一行 -->

<users>
    <user id="1">
        <name>钟离</name>
        <sex>男</sex>
        <adress>璃月</adress>
        <data>3 &lt; 2 &amp;&amp; 5>4</data>
    </user>
    <user id="2">
        <name>甘雨</name>
        <sex>女</sex>
        <adress>璃月</adress>
        <data>3 &lt; 2 &amp;&amp; 5>4</data>
        <!-- 上面的&lt 是 < 号的意思，后边还紧跟着 >，所以不能直接写,下面是另一种解决方法 -->
        <date1>
            <![CDATA[3<2,4>5]]>
        </date1>
    </user>
</users>
        <!-- 以上是根标签，只能有一个 -->
```



## xml解析

| 方法名                               | 说明                                                         |
| ------------------------------------ | ------------------------------------------------------------ |
| List<Element> elements()             | 得到当前元素下所有子元素                                     |
| List<Element>  elements(String name) | 得到当前元素下指定名字的子元素返回集合                       |
| Element  element(String name)        | 得到当前元素下指定名字的子元素,如果有很多名字相同的返回第一个 |
| String  getName()                    | 得到元素名字                                                 |
| String attributeValue(String name)   | 通过属性名直接得到属性值                                     |
| String  elementText(子元素名)        | 得到指定名称的子元素的文本                                   |
| String  getText()                    | 得到文本                                                     |

```java
package test2;

import org.dom4j.Attribute;
import org.dom4j.Document;
import org.dom4j.DocumentException;
import org.dom4j.Element;
import org.dom4j.io.SAXReader;

import java.util.List;
import java.util.function.Consumer;

public class demo1 {
    public static void main(String[] args) throws DocumentException {
        //1.创建一个Dom4j框架提供的解析器对象
        SAXReader saxReader = new SAXReader();

        //2.使用saxreader对象把需要解析的XML文件读成一个Document对象
        Document document = saxReader.read("Day30/src/hollo.xml");

        //3.从文档中解析xml文件的全部数据
        Element root = document.getRootElement();
        System.out.println(root.getName());

        //4.获取根元素下的全部一级子元素
        //List<Element> elements = root.elements();//取得所有元素
        List<Element> elements = root.elements("user");//只取指定的元素
        for(Element element:elements){
            System.out.println(element.getName());
        }

        //5.获取当前元素下的某个子元素
        Element user1=root.element("user");//有很多user子元素，默认拿第一个
        System.out.println(user1.elementText("adress"));

        //6.获取元素的属性信息
        System.out.println(user1.attributeValue("id"));
        Attribute id=user1.attribute("id");
        System.out.println(id.getName());
        System.out.println(id.getValue());

        List<Attribute> attributes = user1.attributes();
        attributes.forEach( attribute->
                System.out.println(attribute.getName()+"=>"+attribute.getValue())
        );

        //7.如何获取全部的文本内容
        System.out.println(user1.elementText("name"));
        System.out.println(user1.elementText("adress"));

        Element data=user1.element("data");
        System.out.println(data.getText());
        System.out.println(data.getTextTrim());//取出文本去除前后空格

    }
}

```

## 写入xml文件

```java
package test2;

import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;

public class demo2 {
    public static void main(String[] args) {
        //1.使用一个StringBuilder对象来拼接数据
        StringBuilder sb=new StringBuilder();
        sb.append("<?xml version=\"1.0\" encoding=\"UTF-8\" ?>").append("\r\n");
        sb.append("<book>").append("\r\n");
        sb.append("<name>").append("从入门到跑路").append("</name>").append("\r\n");
        sb.append("<author>").append("Alice").append("</author>").append("\r\n");
        sb.append("<price>").append(99.99).append("</price>").append("\r\n");
        sb.append("</book>").append("\r\n");
        
        try {
            BufferedWriter bw=new BufferedWriter(new FileWriter("Day30/src/book.xml"));
            bw.write(sb.toString());
            bw.flush();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }

    }
}
```

## 约束xml文件

了解





# 多线程

* 线程(thread)是一个程序内部的一条执行路径。

* 我们之前启动程序执行后，main方法的执行其实就是一条单独的执行路径。

```java
public static void main(String[] args) {
    // 代码…
    for (int i = 0; i < 10; i++) {
        System.out.println(i);
    }
    // 代码...
}
```

* 程序中如果只有一条执行路径，那么这个程序就是单线程的程序。

# 多线程的创建

## 多线程的实现方法1：继承Thread类

①定义一个子类MyThread继承线程类java.lang.Thread，重写run()方法

②创建MyThread类的对象

③调用线程对象的start()方法启动线程（启动后还是执行run方法的）

```java
package test;

public class demo1 {
    public static void main(String[] args) {
        //new一个线程对象
        Thread t=new MyThread();
        //抵用start方法启动线程
        t.start();

        for (int i = 0; i < 5; i++) {
            System.out.println("主线程执行输出："+i);
        }

    }
}

//定义一个线程类，继承Thread类
class MyThread extends Thread {
    //重写run方法，里边是定义线程以后要干啥
    @Override
    public void run() {
        for (int i = 0; i < 5; i++) {
            System.out.println("子线程执行输出：" + i);
        }
    }
}

```

* 优点：编码简单

* **缺点：线程类已经继承Thread，无法继承其他类，不利于扩展。**

>1、为什么不直接调用了run方法，而是调用start启动线程。
>
>* 直接调用run方法会当成普通方法执行，此时相当于还是单线程执行。
>* 只有调用start方法才是启动一个新的线程执行。
>
>2、不要把主线程任务放在子线程之前。
>
>* 这样主线程一直是先跑完的，相当于是一个单线程的效果了。

## 方式二：重写Runnable接口

①定义一个线程任务类MyRunnable实现Runnable接口，重写run()方法

②创建MyRunnable任务对象

③把MyRunnable任务对象交给Thread处理。

④调用线程对象的start()方法启动线程

**Thread的构造器**

| 构造器                                        | 说明                                         |
| --------------------------------------------- | -------------------------------------------- |
| public Thread(String name)                    | 可以为当前线程指定名称                       |
| public Thread(Runnable target)                | 封装Runnable对象成为线程对象                 |
| public Thread(Runnable target ，String name ) | 封装Runnable对象成为线程对象，并指定线程名称 |

```java
package test;

public class demo2 {
    public static void main(String[] args) {
        //创建一个任务对象
        Runnable target = new MyRunnable();
        //把任务对象交给Thread处理
        Thread t = new Thread(target);
        //启动线程
        t.start();

        for (int i = 0; i < 5; i++) {
            System.out.println("主线程执行输出："+i);
        }
    }
}

//定义一个线程任务类 实现Runnable接口
class MyRunnable implements Runnable{
    //重写run方法，定义线程的执行任务
    @Override
    public void run() {
        for (int i = 0; i < 5; i++) {
            System.out.println("子线程执行输出："+i);
        }
    }
}
```

* 优点：线程任务类只是实现接口，可以继续继承类和实现接口，扩展性强。

* 缺点：编程多一层对象包装，如果线程有执行结果是不可以直接返回的。

**用匿名内部类实现Runnable接口**

```java
        //创建一个任务对象
        //Runnable target = new MyRunnable();
        Runnable target = new Runnable(){
            @Override
            public void run() {
                for (int i = 0; i < 5; i++) {
                    System.out.println("子线程执行输出："+ i);
                }
            }
        };
        //把任务对象交给Thread处理
//        new Thread(new Runnable() {
//            @Override
//            public void run() {
//                for (int i = 0; i < 5; i++) {
//                    System.out.println("子线程执行输出："+i);
//                }
//            }
//        }).start();
        new Thread(() ->{
                for (int i = 0; i < 5; i++) {
                    System.out.println("子线程执行输出："+i);
                }
        }).start();
```

## 方案三：利用Callable、FutureTask接口实现。

前2种线程创建方式都存在一个问题：**他们重写的run方法均不能直接返回结果**。不适合需要返回线程执行结果的业务场景。

怎么解决这个问题呢？JDK 5.0提供了Callable和FutureTask来实现。**这种方式的优点是：可以得到线程执行的结果。**

```java
package test;

import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.FutureTask;

//实现Callable接口，结合FutureTask完成
public class demo2 {
    public static void main(String[] args) {
        //创建任务对象
        Callable<String> call = new MyCunnable(100);
        //把callable任务对象交给FutureTask对象
        //FutureTask对象的作用，是Runnable对象（实现接口），可以交给Thread
        //作用2：可以调用get方法得到线程执行的结果
        FutureTask<String> f1=new FutureTask<>(call);
        //交给线程处理
        Thread t1=new Thread(f1);
        //启动线程
        t1.start();

        try {
            //如果f1任务没有结束，这里代码会等待，直到线程1跑完才提取结果
            System.out.println(f1.get());
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
}

//定义一个线程任务类 实现Runnable接口，反省接口
class MyCunnable implements Callable<String> {
    private int n;
    public MyCunnable(int n) {
        this.n = n;
    }
    @Override
    public String call() throws Exception {
        int sum=0;
        for (int i = 0; i < n; i++) {
            sum+=i;
        }
        return "子线程执行的结果是："+sum;
    }
}
```

* 优点：线程任务类只是实现接口，可以继续继承类和实现接口，扩展性强。**可以在线程执行完毕后去获取线程执行的结果。**
* 缺点：编码复杂一点。

# Thread类常用方法

```java
package test;

public class demo1 {
    public static void main(String[] args) {

        Thread t=new MyThread("子线程1号");
        //t.setName("子线程1号");//线程命名
        t.start();
        System.out.println(t.getName());

        Thread t1=new MyThread();
        t1.setName("子线程2号");
        t1.start();
        System.out.println(t1.getName());

        //拿到当前线程对象，谁执行这个方法，就得到哪个线程对象
        Thread m=Thread.currentThread();//主线程默认名称就是main
        System.out.println(m.getName());

        for (int i = 0; i < 5; i++) {
            System.out.println("主线程执行输出："+i);
        }

    }
}

//定义一个线程类，继承Thread类
class MyThread extends Thread {
    public MyThread(){
    }
    public MyThread(String name){
        super(name);//为当前线程对象设置名称，送给父类的有参构造器初始化名称
    }
    //重写run方法，里边是定义线程以后要干啥
    @Override
    public void run() {
        for (int i = 0; i < 5; i++) {
            System.out.println(Thread.currentThread().getName() + i);
        }
    }
}
```

Thread类的线程休眠方法

```java
for (int i = 0; i < 5; i++) {
            System.out.println("输出："+i);
            if(i==3){
                //让线程进入休眠状态
                //public static void sleep(long time) 让当前线程休眠指定的时间后再继续执行，单位为毫秒。
                Thread.sleep(3000);
            }
        }
```

| 方法名称                                | 说明                                          |
| --------------------------------------- | --------------------------------------------- |
| String  getName()                       | 获取当前线程的名称，默认线程名称是Thread-索引 |
| void  setName(String  name)             | 设置线程名称                                  |
| public  static Thread currentThread()： | 返回对当前正在执行的线程对象的引用            |
| public  static void sleep(long time)    | 让线程休眠指定的时间，单位为毫秒。            |
| public  void run()                      | 线程任务方法                                  |
| public  void start()                    | 线程启动方法                                  |

# 线程安全

**线程安全问题出现的原因**？

* **存在多线程并发**
* **同时访问共享资源**
* **存在修改共享资源**

模拟实现：

```java
package test;

public class demo3 {
    public static void main(String[] args) {
        //定义线程类,创建一个共享的账户对象
        Account acc=new Account("213",100000);
        //两个线程对象
        new DrawThread(acc,"小明").start();
        new DrawThread(acc,"小红").start();
        /*
        小明来取钱
        小红来取钱
        余额剩余0.0
        余额剩余-100000.0
        */
    }
}
class Account{
    private String card;
    private double money;

    public Account(String card, double money) {
        this.card = card;
        this.money = money;
    }

    public void drawMoney(int n){
        //先获取谁在取钱，线程名就是人名
        String name = Thread.currentThread().getName();
        if(this.money>=n) {
            System.out.println(name+"来取钱");
            money -= n;
            System.out.println("余额剩余"+money);
        } else
            System.out.println(name+"余额不足");
    }
    public String getCard() {
        return card;
    }

    public void setCard(String card) {
        this.card = card;
    }

    public double getMoney() {
        return money;
    }

    public void setMoney(double money) {
        this.money = money;
    }
}

//取钱的线程类
class DrawThread extends Thread{
    private Account acc;
    public DrawThread(Account acc,String name){
        super(name);
        this.acc=acc;
    }
    @Override
    public void run() {
        acc.drawMoney(100000);
    }
}
```

# 线程同步

**加锁，把共享资源进行上锁，每次只能一个线程进入访问完毕以后解锁，然后其他线程才能进来。**

## 同步代码块

作用：把出现线程安全问题的核心代码给上锁

原理：每次只能一个线程进入，执行完毕后自动解锁，其他线程才可以进来执行。

```java
synchronized(同步锁对象) {
  操作共享资源的代码(核心代码)
 }
```

**锁对象要求：理论上锁对象只要对于当前同时执行的线程来说是同一个对象即可。**

**锁对象不能用唯一的对象，因为会影响其他无关进程**



**锁对象的规范要求：**

* **规范上：建议使用共享资源作为锁对象。**

* **对于实例方法建议使用this作为锁对象。**

* **对于静态方法建议使用字节码（类名.class）对象作为锁对象。**

## 同步方法

* 作用：把出现线程安全问题的核心方法给上锁。

* 原理：每次只能一个线程进入，执行完毕以后自动解锁，其他线程才可以进来执行。

```java
修饰符 synchronized 返回值类型 方法名称(形参列表) {
    操作共享资源的代码
}
```

> 底层原理
>
> * 同步方法其实底层也是有隐式锁对象的，只是**锁的范围是整个方法代码**。
>
> * 如果方法是**实例方法**：同步方法默认用this作为的锁对象。但是代码要高度面向对象！
>
> * 如果方法是**静态方法**：同步方法默认用类名.class作为的锁对象。

```java
package test;

public class demo3 {
    public static void main(String[] args) {
        //定义线程类,创建一个共享的账户对象
        Account acc = new Account("213", 100000);
        //两个线程对象
        new DrawThread(acc, "小明").start();
        new DrawThread(acc, "小红").start();
        /*
        小明来取钱
        小红来取钱
        余额剩余0.0
        余额剩余-100000.0
        */
    }
}

class Account {
    public static void run() {
        //对于静态方法建议使用字节码（类名.class）对象作为锁对象。
        synchronized (Account.class) {

        }
    }

    private String card;
    private double money;

    public Account(String card, double money) {
        this.card = card;
        this.money = money;
    }

    //    public void drawMoney(int n){
//        //先获取谁在取钱，线程名就是人名
//        String name = Thread.currentThread().getName();
//        //对于实例方法建议使用this作为锁对象。
//        synchronized (this)  {
//            if (this.money >= n) {
//                System.out.println(name + "来取钱");
//                money -= n;
//                System.out.println("余额剩余" + money);
//            } else
//                System.out.println(name + "余额不足");
//        }
//    }
    public synchronized void drawMoney(int n) {
        //先获取谁在取钱，线程名就是人名
        String name = Thread.currentThread().getName();

        if (this.money >= n) {
            System.out.println(name + "来取钱");
            money -= n;
            System.out.println("余额剩余" + money);
        } else
            System.out.println(name + "余额不足");

    }
}

//取钱的线程类
class DrawThread extends Thread {
    private Account acc;

    public DrawThread(Account acc, String name) {
        super(name);
        this.acc = acc;
    }

    @Override
    public void run() {
        acc.drawMoney(100000);
    }
}
```

同步代码块和同步方法谁更好一点，性能上来说同步代码块好一点，因为同步代码块范围更小，范围更小性能越好，就相当于上厕所，在厕所外边排队和对着坑位排队一样，对着坑位排队就更快一点。

## Lock锁

```java
class Account {
    private String card;
    private double money;
    //final修饰后：锁对象是唯一和不可替换的，非常专业
    private final Lock lock=new ReentrantLock();
    public Account(String card, double money) {
        this.card = card;
        this.money = money;
    }
    public synchronized void drawMoney(int n) {
        //先获取谁在取钱，线程名就是人名
        String name = Thread.currentThread().getName();
        lock.lock();//上锁
        try {
            if (this.money >= n) {
                System.out.println(name + "来取钱");
                money -= n;
                System.out.println("余额剩余" + money);
            } else
                System.out.println(name + "余额不足");
        } finally {
            lock.unlock();//避免上述代码出现异常，导致永远无法解锁，产生死锁
        }
    }
}
```

# 线程通信

```java
package test;

import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class demo3 {
    public static void main(String[] args) {
        //定义线程类,创建一个共享的账户对象
        Account acc = new Account("213", 100000);
        //两个取钱线程对象
        new DrawThread(acc, "小明").start();
        new DrawThread(acc, "小红").start();
        //三个存钱线程
        new DepositThread(acc, "亲爹").start();
        new DepositThread(acc, "干爹").start();
        new DepositThread(acc, "岳父").start();

    }
}

class Account {
    private String card;
    private double money;
    //final修饰后：锁对象是唯一和不可替换的，非常专业
    private final Lock lock = new ReentrantLock();

    public Account(String card, double money) {
        this.card = card;
        this.money = money;
    }

    public synchronized void drawMoney(int n) {//一定要保证线程安全
        //先获取谁在取钱，线程名就是人名
        String name = Thread.currentThread().getName();
        try {
            if (this.money >= n) {
                System.out.println(name + "来取钱");
                money -= n;
                System.out.println("余额剩余" + money);
            } else {
                //钱不够，就唤醒别人，等待自己
                this.notifyAll();//唤醒所有线程
                this.wait();//锁对象，让当前线程陷入等待
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public synchronized void depositMoney(int n) {
        String name=Thread.currentThread().getName();
        try {
            if(this.money==0){
                //没钱了存钱
                this.money+=n;
                System.out.println(name+"存钱"+money+"，成功后的余额"+money);
                //有钱了唤醒别人，等待自己
                this.notifyAll();;
                this.wait();//让当前线程等待
            }else{
                //有钱就不存钱
                this.notifyAll();
                this.wait();
            }
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
}

//取钱的线程类
class DrawThread extends Thread {
    private Account acc;

    public DrawThread(Account acc, String name) {
        super(name);
        this.acc = acc;
    }

    @Override
    public void run() {
        while (true) {
            acc.drawMoney(100000);
            try {
                Thread.sleep(3000);
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        }
    }
}
class DepositThread extends Thread {
    private Account acc;

    public DepositThread(Account acc, String name) {
        super(name);
        this.acc = acc;
    }

    @Override
    public void run() {
        while (true) {
            acc.depositMoney(100000);
            try {
                Thread.sleep(2000);
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        }
    }
}
```



**Object类的等待和唤醒方法：**

| 方法名称         | 说明                                                         |
| ---------------- | ------------------------------------------------------------ |
| void  wait()     | 让当前线程等待并释放所占锁，直到另一个线程调用notify()方法或 notifyAll()方法 |
| void  notify()   | 唤醒正在等待的单个线程                                       |
| void notifyAll() | 唤醒正在等待的所有线程                                       |

**上述方法应该使用当前同步锁对象进行调用。(就是只能用锁对象调用)**

# 线程池

线程池就是一个可以复用线程的技术。

ThreadPoolExecutor构造器的参数说明：

`public ThreadPoolExecutor(int corePoolSize,
              int maximumPoolSize,
              long keepAliveTime,
              TimeUnit unit,
              BlockingQueue<Runnable> workQueue,
              ThreadFactory threadFactory,
              RejectedExecutionHandler handler)`

![image-20230629131446900](C:\Users\痞妖\AppData\Roaming\Typora\typora-user-images\image-20230629131446900.png)

**参数的解释**：

![image-20230629131557630](C:\Users\痞妖\AppData\Roaming\Typora\typora-user-images\image-20230629131557630.png)

 **临时线程什么时候创建啊？**

* 新任务提交时发现核心线程都在忙，任务队列也满了，并且还可以创建临时线程，此时才会创建临时线程。

**什么时候会开始拒绝任务？**

* 核心线程和临时线程都在忙，任务队列也满了，新的任务过来的时候才会开始任务拒绝。

| 方法名称                            | 说明                                                         |
| ----------------------------------- | ------------------------------------------------------------ |
| void execute(Runnable command)      | 执行任务/命令，没有返回值，一般用来执行  Runnable 任务       |
| Future<T>  submit(Callable<T> task) | 执行任务，返回未来任务对象获取线程结果，一般拿来执行  Callable 任务 |
| void  shutdown()                    | 等任务执行完毕后关闭线程池                                   |
| List<Runable> shutdownNow()         | 立刻关闭，停止正在执行的任务，并返回队列中未执行的任务       |

## 线程池处理Runnable任务

**拒绝策略**：

| 策略                                   | 详解                                                         |
| -------------------------------------- | ------------------------------------------------------------ |
| ThreadPoolExecutor.AbortPolicy         | 丢弃任务并抛出RejectedExecutionException异常。**是默认的策略** |
| ThreadPoolExecutor.DiscardPolicy：     | 丢弃任务，但是不抛出异常  这是不推荐的做法                   |
| ThreadPoolExecutor.DiscardOldestPolicy | 抛弃队列中等待最久的任务  然后把当前任务加入队列中           |
| ThreadPoolExecutor.CallerRunsPolicy    | 由主线程负责调用任务的run()方法从而绕过线程池直接执行        |

```java
package test;

import java.util.concurrent.*;

public class demo5 {
    public static void main(String[] args) {
        ExecutorService pool = new ThreadPoolExecutor(3,5,8, TimeUnit.SECONDS,
                new ArrayBlockingQueue<>(4), Executors.defaultThreadFactory(),new ThreadPoolExecutor.AbortPolicy());//此时的拒绝策略是抛出异常
        //执行runnable任务
        Runnable target=new MyRunnable();
        pool.execute(target);//自动创建一个新线程，自动处理这个任务，自动执行
        pool.execute(target);//自动创建一个新线程，自动处理这个任务，自动执行
        pool.execute(target);//自动创建一个新线程，自动处理这个任务，自动执行
        //pool.execute(target);//复用核心线程
        //pool.execute(target);//复用核心线程

        //提高线程的休眠时间，新创建的这些线程就进入任务队列排队
        pool.execute(target);//排队
        pool.execute(target);//排队
        pool.execute(target);//排队
        pool.execute(target);//排队
        //没有空闲的核心线程并且此时任务队列已满，到了创建临时线程的时机了
        pool.execute(target);//创建第一个
        pool.execute(target);//创建第二个，最大线程数量是5，核心线程是3，所以最多创建两个

        //核心线程和临时线程都在忙，并且任务队列已满，到了拒接任务的时机l
        pool.execute(target);

        //上述代码执行完毕之后，程序并不会结束，因为核心线程本身就要一直存在着，要么手动关闭程序，要么调用API
        //pool.shutdown();//等着线程池的任务全都执行完毕后，再关闭线程池
        //pool.shutdownNow();//立即关闭线程池
    }

}
class MyRunnable implements Runnable{

    @Override
    public void run() {
        //任务是干啥的
        System.out.println(Thread.currentThread().getName()+"==>输出666");
        try {
            Thread.sleep(100000);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
    }
}
```

## 线程池处理Callable任务

```java
package test;

import java.util.concurrent.*;

public class demo6 {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        ExecutorService pool = new ThreadPoolExecutor(3,5,8, TimeUnit.SECONDS,
                new ArrayBlockingQueue<>(4), Executors.defaultThreadFactory(),new ThreadPoolExecutor.AbortPolicy());//此时的拒绝策略是抛出异常

        //使用线程处理Callable任务
        Future<String> f1 = pool.submit(new MyCallable(100));
        Future<String> f2 = pool.submit(new MyCallable(200));
        Future<String> f3 = pool.submit(new MyCallable(300));
        Future<String> f4 = pool.submit(new MyCallable(400));
        Future<String> f5 = pool.submit(new MyCallable(500));

        System.out.println(f1.get());
        System.out.println(f2.get());
        System.out.println(f3.get());
        System.out.println(f4.get());
        System.out.println(f5.get());
    }
}
class MyCallable implements Callable<String>{
    private int n;
    public MyCallable(int n){
        this.n=n;
    }

    @Override
    public String call() throws Exception {
        //描述线程任务
        //需求：求1-n的和返回
        int sum=0;
        for(int i=1;i<=n;++i){
            sum+=i;
        }
        return Thread.currentThread().getName()+"线程求出结果"+sum;
    }
}
```

## Executors工具类实现线程池

Executors：线程池的工具类通过调用方法返回不同类型的线程池对象。

| 方法名称                                                     | 说明                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| public static ExecutorService newCachedThreadPool()          | 线程数量随着任务增加而增加，如果线程任务执行完毕且空闲了一段时间则会被回收掉。 |
| public static ExecutorService newFixedThreadPool(int nThreads) | 创建固定线程数量的线程池，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程替代它。 |
| public static ExecutorService newSingleThreadExecutor()      | 创建只有一个线程的线程池对象，如果该线程出现异常而结束，那么线程池会补充一个新线程。 |
| public  static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) | 创建一个线程池，可以实现在给定的延迟后运行任务，或者定期执行任务。 |



**大型并发系统环境中使用Executors如果不注意可能会出现系统风险。**

![image-20230706132752340](C:\Users\痞妖\AppData\Roaming\Typora\typora-user-images\image-20230706132752340.png)

![image-20230706132954072](C:\Users\痞妖\AppData\Roaming\Typora\typora-user-images\image-20230706132954072.png)

# 线程的生命周期

![image-20230706134023421](C:\Users\痞妖\AppData\Roaming\Typora\typora-user-images\image-20230706134023421.png)

# ThreadLocal的介绍：

jdbc中补充的

JDK 1.2的版本中就提供java.lang.ThreadLocal，为解决多线程程序的并发问题提供了一种新的思路。
使用这个工具类可以很简洁地编写出优美的多线程程序。通常用来在在多线程中管理共享数据库连接、Session等

**ThreadLocal用于保存某个线程共享变量，原因是在Java中**，每一个线程对象中都有一个ThreadLocalMap<ThreadLocal, Object>，其key就是一个ThreadLocal，而Object即为该线程的共享变量。而这个map是通过ThreadLocal的set和get方法操作的。对于同一个static ThreadLocal，不同线程只能从中get，set，remove自己的变量，而不会影响其他线程的变量。

1、ThreadLocal对象.get: 获取ThreadLocal中当前线程共享变量的值。

2、ThreadLocal对象.set: 设置ThreadLocal中当前线程共享变量的值。

3、ThreadLocal对象.remove: 移除ThreadLocal中当前线程共享变量的值。

# 网络编程

<img src="C:\Users\痞妖\AppData\Roaming\Typora\typora-user-images\image-20230706205621721.png" alt="image-20230706205621721" style="zoom:67%;" />

<img src="C:\Users\痞妖\AppData\Roaming\Typora\typora-user-images\image-20230706205704534.png" alt="image-20230706205704534" style="zoom:67%;" />

# 网络编程三要素

## ip地址

| 名称                                              | 说明                                             |
| ------------------------------------------------- | ------------------------------------------------ |
| public static InetAddress getLocalHost()          | 返回本主机的地址对象                             |
| public static  InetAddress getByName(String host) | 得到指定主机的IP地址对象，参数是域名或者IP地址   |
| public String  getHostName()                      | 获取此IP地址的主机名                             |
| public String  getHostAddress()                   | 返回IP地址字符串                                 |
| public boolean isReachable(int timeout)           | 在指定毫秒内连通该IP地址对应的主机，连通返回true |

```java
 		//获取本机IP地址对象的主机名和IP地址
        InetAddress ip1=InetAddress.getLocalHost();
        System.out.println(ip1.getHostName());
        System.out.println(ip1.getHostAddress());

        //获取指定域名和ip的IP地址
        InetAddress ip2= InetAddress.getByName("www.baidu.com");
        System.out.println(ip2.getHostName());
        System.out.println(ip2.getHostAddress());

        //判断主机之间是否联通，相当于ping
        System.out.println(ip2.isReachable(6000));

```

## 端口号

端口号：标识正在计算机设备上运行的进程（程序），被规定为一个 16 位的二进制，范围是 0~65535。



**端口类型**：

周知端口：0~1023，被预先定义的知名应用占用（如：HTTP占用 80，FTP占用21） 

**注册端口**：1024~49151，分配给用户进程或某些应用程序。（如：Tomcat占 用8080，MySQL占用3306）

动态端口：49152到65535，之所以称为动态端口，是因为它 一般不固定分配某种进程，而是动态分配。

==我们自己开发的程序选择注册端口，且一个设备中不能出现两个程序的端口号一样，否则出错。==

## 协议

...

# UDP

![image-20230707100329270](C:\Users\痞妖\AppData\Roaming\Typora\typora-user-images\image-20230707100329270.png)

![image-20230707100341633](C:\Users\痞妖\AppData\Roaming\Typora\typora-user-images\image-20230707100341633.png)

**需求：客户端实现步骤**

①创建DatagramSocket对象（发送端对象）           扔韭菜的人

②创建DatagramPacket对象封装需要发送的数据（数据包对象）         韭菜盘子

③使用DatagramSocket对象的send方法传入DatagramPacket对象         开始抛出韭菜

④释放资源

**需求：接收端实现步骤**

①创建DatagramSocket对象并指定端口（接收端对象）           接韭菜的人

②创建DatagramPacket对象接收数据（数据包对象）         韭菜盘子

③使用DatagramSocket对象的receive方法传入DatagramPacket对象         开始接收韭菜

④释放资源

```java
//Client.java
package test;

import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.util.Scanner;

public class Client {
    public static void main(String[] args) throws Exception {
        //1. 创建客户端对象
        DatagramSocket socket = new DatagramSocket();

        //2. 创建数据包对象封装要发送出去的数据
        Scanner sc = new Scanner(System.in);
        while (sc.hasNext()) {
            String s=sc.next();
            byte[] bytes=s.getBytes();
            DatagramPacket packet = new DatagramPacket(bytes,bytes.length, InetAddress.getLocalHost(),6666);

            //3. 开始发送这个数据包出去
            socket.send(packet);
        }

        System.out.println("客户端发送数据完毕");
        socket.close();//释放资源

    }
}
```

```java
//Server.java
package test;

import java.io.IOException;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.SocketException;

public class Server {
    public static void main(String[] args) throws IOException {
        //先启动服务端，再启动客户端
        System.out.println("服务端启动");
        //1. 创建一个服务端对象
        DatagramSocket socket = new DatagramSocket(6666);

        //2. 创建一个数据包对象，用来接收数据
        byte[] buffer = new byte[1024*64];
        DatagramPacket packet = new DatagramPacket(buffer,buffer.length);

        while (true) {
            //3. 开始正式使用数据包来接收客户端发来的数据
            socket.receive(packet);

            //4. 从字节数组中，把接收到的数据直接打印出来
            //接受多少就倒出多少
            int len=packet.getLength();
            String rs = new String(buffer,0,len);
            System.out.println(rs);

            System.out.println(packet.getAddress().getHostAddress());
            System.out.println(packet.getPort());
        }

        //socket.close();
    }
}
```

# TCP

## 客户端

<img src="C:\Users\痞妖\AppData\Roaming\Typora\typora-user-images\image-20230707143820097.png" alt="image-20230707143820097" style="zoom:67%;" />

**需求：客户端实现步骤**

①创建客户端的Socket对象，请求与服务端的连接。

②使用socket对象调用getOutputStream()方法得到字节输出流。

③使用字节输出流完成数据的发送。

④释放资源：关闭socket管道。

## 服务端

<img src="C:\Users\痞妖\AppData\Roaming\Typora\typora-user-images\image-20230707180349063.png" alt="image-20230707180349063" style="zoom:67%;" />

**需求：服务端实现步骤**

①创建ServerSocket对象，注册服务端端口。

②调用ServerSocket对象的accept()方法，等待客户端的连接，并得到Socket管道对象。

③通过Socket对象调用getInputStream()方法得到字节输入流、完成数据的接收。

④释放资源：关闭socket管道

```java
//Client
package test;

import java.io.DataOutputStream;
import java.io.OutputStream;
import java.net.InetAddress;
import java.net.Socket;
import java.util.Scanner;

public class TCP_Client {
    public static void main(String[] args) throws Exception {
        //1. 创建Socket对象，并请求与服务器程序的链接
        Socket socket = new Socket(InetAddress.getLocalHost().getHostAddress(), 8888);

        //2. 从socket通信管道中得到一个字节输出流，用来发数据给服务端程序
        OutputStream os= socket.getOutputStream();

        //3. 把低级的字节输出流包装成数据输出流
        DataOutputStream dos = new DataOutputStream(os);

        //4. 写数据出去
        Scanner sc = new Scanner(System.in);
        while (sc.hasNext()) {
            dos.writeUTF(sc.next());
            dos.flush();
        }

        dos.close();
        socket.close();
    }
}
```

```java
//Server
package test;

import java.io.DataInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.ServerSocket;
import java.net.Socket;

public class TCP_Server {
    public static void main(String[] args) throws Exception {
        //1. 创建对象，同时为服务端注册端口
        ServerSocket serverSocket = new ServerSocket(8888);

        //2. 使用对象的accept方法等待客户端的连接请求
        Socket socket = serverSocket.accept();//阻塞

        //3. 从socket的输入管道中得到一个字节输入流
        InputStream is = socket.getInputStream();

        //4. 将原始的字节输入流，包装成一个数据输入流
        DataInputStream dis = new DataInputStream(is);

        //5. 使用数据输入流读取客户端发来的消息
        while (true) {
            try {
                String rs = dis.readUTF();
                System.out.println(rs);
                //其实也可以获取客户端的ip地址
                System.out.println(socket.getRemoteSocketAddress());
            } catch (IOException e) {
                System.out.println("对方已离线");
                break;
            }
        }

        dis.close();
        socket.close();
    }
}
```

## 支持与多个客户端同时通信（同时接受多个客户端消息）

<img src="C:\Users\痞妖\AppData\Roaming\Typora\typora-user-images\image-20230707192605696.png" alt="image-20230707192605696" style="zoom:67%;" />

```java
//Client
package test;

import java.io.DataOutputStream;
import java.io.OutputStream;
import java.net.InetAddress;
import java.net.Socket;
import java.util.Scanner;

public class TCP_Client {
    public static void main(String[] args) throws Exception {
        //1. 创建Socket对象，并请求与服务器程序的链接
        Socket socket = new Socket(InetAddress.getLocalHost().getHostAddress(), 8888);

        //2. 从socket通信管道中得到一个字节输出流，用来发数据给服务端程序
        OutputStream os= socket.getOutputStream();

        //3. 把低级的字节输出流包装成数据输出流
        DataOutputStream dos = new DataOutputStream(os);

        //4. 写数据出去
        Scanner sc = new Scanner(System.in);
        while (sc.hasNext()) {
            dos.writeUTF(sc.next());
            dos.flush();
        }

        dos.close();
        socket.close();
    }
}
```



```java
//Server
package test;

import java.io.DataInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.ServerSocket;
import java.net.Socket;

public class TCP_Server {
    public static void main(String[] args) throws Exception {
        //1. 创建对象，同时为服务端注册端口
        ServerSocket serverSocket = new ServerSocket(8888);

        while (true) {
            //2. 使用对象的accept方法等待客户端的连接请求
            Socket socket = serverSocket.accept();//阻塞
            System.out.println("有人上线了"+socket.getRemoteSocketAddress());
            //把这个socket通信管道，交给一个独立的线程
            new TCP_ServerReaderThread(socket).start();
        }
    }
}
```



```java
//ServerThread
package test;

import java.io.DataInputStream;
import java.io.IOException;
import java.net.Socket;

public class TCP_ServerReaderThread extends Thread{
    private Socket socket;
    TCP_ServerReaderThread(Socket socket){
        this.socket=socket;
    }
    @Override
    public void run() {
        try {
            DataInputStream dis=new DataInputStream(socket.getInputStream());
            while(true){
                try {
                    System.out.println(dis.readUTF());
                } catch (Exception e) {
                    System.out.println("有人下线了"+socket.getRemoteSocketAddress());
                    socket.close();
                    dis.close();
                    break;
                }
            }
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
}
```

# 单元测试

JUnit单元测试的实现过程是什么样的？

* 必须导入Junit框架的jar包。
* **定义的测试方法必须是无参数无返回值，且公开的方法。**
* **测试方法使用@Test注解标记。**

```java
//实现的工具类
package test;

public class demo7 {
    public static void printNumber(String name){
        System.out.println("名字的长度是"+name.length());
    }
    //取最大索引
    public static int getMaxIndex(String data){
        if(data==null)
            return -1;
        return data.length();
    }
}
```

```java
//实现的测试类
package test;

import org.junit.Assert;
import org.junit.Test;

import static org.junit.Assert.assertArrayEquals;

public class demo6 {
    @Test //测试方法
    public void testdemo7() {
        demo7.printNumber("admin");//测试成功
        demo7.printNumber(null);//测试失败
    }

    @Test
    public void testdemo72() {
        System.out.println(demo7.getMaxIndex("hello"));//没有抛出异常，但是结果是错的，因为最大索引不是字符串的长度
        System.out.println(demo7.getMaxIndex(null));
        //所以引入了断言机制，程序员可以预测业务方法的结果
        int t = demo7.getMaxIndex("hello");
        Assert.assertEquals("玩原神玩的", 4, 7);
    }
}
```

**Junit常用注解(Junit 4.xxxx版本)**

| 注解         | 说明                                                         |
| ------------ | ------------------------------------------------------------ |
| @Test        | 测试方法                                                     |
| @Before      | 用来修饰实例方法，该方法会在每一个测试方法执行之前执行一次。 |
| @After       | 用来修饰实例方法，该方法会在每一个测试方法执行之后执行一次。 |
| @BeforeClass | 用来静态修饰方法，该方法会在所有测试方法之前只执行一次。     |
| @AfterClass  | 用来静态修饰方法，该方法会在所有测试方法之后只执行一次。     |

```java
package test;

import org.junit.*;

import static org.junit.Assert.assertArrayEquals;

public class demo6 {
    @Before
    public void beforeTest(){
        System.out.println("before~~~");
    }
    @After
    public void afterTest(){
        System.out.println("After~~~");
    }
    @BeforeClass
    public static void beforeClassTest(){
        System.out.println("beforeClass~~~");
    }
    @AfterClass
    public static void afterClassTest(){
        System.out.println("AfterClass~~~");
    }
    @Test //测试方法
    public void testdemo7() {
        demo7.printNumber("admin");//测试成功
        demo7.printNumber(null);//测试失败
    }

    @Test
    public void testdemo72() {
        System.out.println(demo7.getMaxIndex("hello"));//没有抛出异常，但是结果是错的，因为最大索引不是字符串的长度
        System.out.println(demo7.getMaxIndex(null));
        //所以引入了断言机制，程序员可以预测业务方法的结果
        int t = demo7.getMaxIndex("hello");
        Assert.assertEquals("玩原神玩的", 4, t);
    }
}
```

* 开始执行的方法:初始化资源。

* 执行完之后的方法:释放资源。

<img src="C:\Users\痞妖\AppData\Roaming\Typora\typora-user-images\image-20230708152411014.png" alt="image-20230708152411014" style="zoom:50%;" />

# 反射

* 反射是指对于任何一个Class类，在"运行的时候"都可以直接得到这个类全部成分。

* 在运行时,可以直接得到这个类的构造器对象：Constructor

* 在运行时,可以直接得到这个类的成员变量对象：Field

* 在运行时,可以直接得到这个类的成员方法对象：Method

* 这种运行时动态获取类信息以及动态调用类中成分的能力称为Java语言的反射机制。

**获取Class类对象**

方式一：Class c1 = Class.forName(“全类名”);
方式二：Class c2 = 类名.class
方式三：Class c3 = 对象.getClass();

```java
package test2;

public class demo1 {
    public static void main(String[] args) throws Exception {
        Class c1 = Student.class;
        System.out.println(c1.getName()); //全类名
        System.out.println(c1.getSimpleName()); //普通的类名

        Class c2 = Class.forName("test2.Student");
        System.out.println(c1==c2);

        Student s=new Student();
        Class c3=s.getClass();
        System.out.println(c2==c3);
                
    }
}
```

<img src="C:\Users\痞妖\AppData\Roaming\Typora\typora-user-images\image-20230708215549924.png" alt="image-20230708215549924" style="zoom:%;" />

<img src="C:\Users\痞妖\AppData\Roaming\Typora\typora-user-images\image-20230708215615778.png" alt="image-20230708215615778" style="zoom:%;" />

```java
        Class c1 = Student.class;
        //获取类的某个构造器
        Constructor constructor=c1.getDeclaredConstructor();
        System.out.println(constructor.getName()+"--->"+constructor.getParameterCount());
        constructor.setAccessible(true);
        Student student= (Student) constructor.newInstance();
        System.out.println(student);
```

<img src="C:\Users\痞妖\AppData\Roaming\Typora\typora-user-images\image-20230708222915233.png" alt="image-20230708222915233" style="zoom:67%;" />

<img src="C:\Users\痞妖\AppData\Roaming\Typora\typora-user-images\image-20230708222930019.png" alt="image-20230708222930019" style="zoom:67%;" />

<img src="C:\Users\痞妖\AppData\Roaming\Typora\typora-user-images\image-20230708222946124.png" alt="image-20230708222946124" style="zoom:67%;" />

<img src="C:\Users\痞妖\AppData\Roaming\Typora\typora-user-images\image-20230708222957544.png" alt="image-20230708222957544" style="zoom:67%;" />

```java
//Student.java
package test2;

public class Student {
    private String name;
    private int age;
    private Student(){}
    public Student(String name,int age){
        this.name=name;
        this.age=age;
    }

    @Override
    public String toString() {
        return "Student{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }
    public void eat(){
        System.out.println("吃饱了");
    }
    private String cook(String food){
        System.out.println("做好饭了");
        return food;
    }
}
```

```java
//Test.java
package test2;

import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Method;

public class demo1 {
    public static void main(String[] args) throws Exception {
        Class c1 = Student.class;
        //获取类的某个构造器
        Constructor constructor=c1.getDeclaredConstructor();
        System.out.println(constructor.getName()+"--->"+constructor.getParameterCount());
        constructor.setAccessible(true);
        Student student= (Student) constructor.newInstance();
        System.out.println(student);

        //定位某个成员变量
        Field fName = c1.getDeclaredField("name");
        System.out.println(fName.getName()+"-->"+fName.getType());
        //赋值
        Student student2 = new Student("钟离",500);
        fName.setAccessible(true);
        fName.set(student2,"甘雨");
        System.out.println(student2);
        //取值
        String name= (String) fName.get(student2);
        System.out.println(name);

        //取成员方法
        Method eat = c1.getDeclaredMethod("eat");
        System.out.println(eat.getName()+"-->"+eat.getParameterCount()+"-->"+eat.getReturnType());
        Method cook=c1.getDeclaredMethod("cook",String.class);
        //执行
        cook.setAccessible(true);
        String rs = (String) cook.invoke(student2, "杏仁豆腐");
        System.out.println(rs);

    }
}
```



反射的作用？

**可以在运行时得到一个类的全部成分然后操作。**

**可以破坏封装性。（很突出）**

**也可以破坏泛型的约束性。（很突出）**

**更重要的用途是适合：做Java高级框架**

**基本上主流框架都会基于反射设计一些通用技术功能。**

# 注解

* Java 注解（Annotation）又称 Java 标注，是 JDK5.0 引入的一种注释机制。

* Java 语言中的类、构造器、方法、成员变量、参数等都可以被注解进行标注。

**自定义注解**

```
public @interface 注解名称 {
	public 属性类型 属性名() default 默认值 ;
}
```



元注解：

**@Target约束自定义注解可以标记的范围。
@Retention用来约束自定义注解的存活范围。**

<img src="C:\Users\痞妖\AppData\Roaming\Typora\typora-user-images\image-20230709104506307.png" alt="image-20230709104506307" style="zoom:67%;" />

注解解析：

<img src="C:\Users\痞妖\AppData\Roaming\Typora\typora-user-images\image-20230709104638611.png" alt="image-20230709104638611" style="zoom:67%;" />

**解析注解的技巧**

* 注解在哪个成分上，我们就先拿哪个成分对象。

* 比如注解作用成员方法，则要获得该成员方法对应的Method对象，再来拿上面的注解

* 比如注解作用在类上，则要该类的Class对象，再来拿上面的注解

* 比如注解作用在成员变量上，则要获得该成员变量对应的Field对象，再来拿上面的注解

```java
//MyTest
package test2;

import java.lang.annotation.*;

@Target({ElementType.METHOD,ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
public @interface MyTest {
    String value();
    double aaa() default 100;
    String[] bbb();
}
```

```java
//demo.java
package test2;

@MyTest(value="甘雨",aaa=10000,bbb={"海灯节","秘书"})
public class demo {
    @MyTest(value="刻晴",aaa=18,bbb={"璃月港","牛杂师傅"})
    public void test(){

    }
}
```

```java
//AnnotationTest.java
package test2;

import org.junit.Test;

import java.lang.annotation.Annotation;
import java.lang.reflect.Method;
import java.util.Arrays;

public class AnnotationTest {
    @Test
    public void parseClass() throws NoSuchMethodException {
        //1. 先得到Class对象
        Class c=demo.class;
        //2. 解析类上的注解
        //判断这个类上是否包含某个注解
        if (c.isAnnotationPresent(MyTest.class)){
            MyTest myTest = (MyTest) c.getDeclaredAnnotation(MyTest.class);
            System.out.println(myTest.value());
            System.out.println(myTest.aaa());
            System.out.println(Arrays.toString(myTest.bbb()));

        }
        //3. 解析方法上的注解
        //判断这个方法上是否包含某个注解
        Method method = c.getDeclaredMethod("test");
        if (method.isAnnotationPresent(MyTest.class)){
            MyTest myTest = (MyTest) method.getDeclaredAnnotation(MyTest.class);
            System.out.println(myTest.value());
            System.out.println(myTest.aaa());
            System.out.println(Arrays.toString(myTest.bbb()));

        }
    }
}
```

# 动态代理

![image-20230709141443372](C:\Users\痞妖\AppData\Roaming\Typora\typora-user-images\image-20230709141443372.png)

```java
//BigStar
package test3;

public class BigStar implements Star {
    private String name;
    public BigStar(){
    }
    public BigStar(String name) {
        this.name = name;
    }
    public void Sing(){
        System.out.println(name+"在唱歌");
    }
    public String Dance(){
        System.out.println(name+"在跳舞");
        return "谢谢大家";
    }
}
```

```java
//Star
package test3;

public interface Star {
    public void Sing();
    public String Dance();
}
```

```java
//ProxyUtil
package test3;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

public class ProxyUtil{
    /*public static Object newProxyInstance(ClassLoader loader,
                                          Class<?>[] interfaces,
                                          InvocationHandler h)*/
    public static Star createProxy(BigStar bigStar) {
        Star starProxy = (Star) Proxy.newProxyInstance(ProxyUtil.class.getClassLoader(), new Class[]{Star.class},
                new InvocationHandler() {
                    @Override//回调方法
                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                        //代理对象要做的事
                        if (method.getName().equals("Sing")) {
                            System.out.println("准备话筒，收费160原石");
                        }else if(method.getName().equals("Dance")){
                            System.out.println("消耗120体力");
                        }
                        return method.invoke(bigStar,args);
                    }
                });
        return starProxy;
    }
}
```

```java
//Test
package test3;

public class Test {
    public static void main(String[] args) {
        BigStar s=new BigStar("甘雨");
        Star starProxy = ProxyUtil.createProxy(s);
        starProxy.Sing();
        starProxy.Dance();
    }
}
```

























​	
