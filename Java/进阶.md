问

c++的编译过程



答：

2023/5/19 17:12:35

C++的编译过程包括预处理、编译、汇编和链接四个阶段。

1. 预处理（Preprocessing）：在这个阶段，C++编译器会先对源代码进行预处理，替换所有的宏定义并处理所有的条件编译指令。例如，#define将被展开为真实的定义内容，并执行#ifdef或#ifndef语句的条件判断，并对符号常量计算表达式值等，最终得到一个经过预处理后的完整源文件。
2. 编译（Compilation）：在预处理完成后，C++编译器将根据经过预处理后的源代码生成汇编代码，也就是将高级的C++代码翻译成汇编语言的阶段。在这一阶段中，编译器将对源代码进行词法分析、语法分析、语义分析和优化等工作，最终生成与目标平台相关的汇编代码文件。
3. 汇编（Assembly）：在此阶段中，汇编器将接收文本格式的汇编代码，并将其转换为二进制机器码文件，即目标文件，其中每条汇编代码都对应了机器指令，已经是可以被计算机直接执行的代码。
4. 链接（Linking）：在整个编译过程的最后，连接器将不同的目标文件和库文件组合起来，生成最终可执行文件。链接的主要工作包括符号解析、重定位和库函数链接等。在这个过程中，如果缺少所需的符号或者函数定义，则会产生链接错误。

总的来说，C++编译过程将源代码转换为可在计算机上运行的机器码，其中预处理和编译阶段与C语言类似，而汇编和链接阶段则更接近底层的计算机架构。



问：

2023/5/19 17:12:45

java的编译过程



答：

2023/5/19 17:13:38

Java的编译过程可以分为四个主要阶段：词法分析与语法分析、语义分析、字节码生成以及优化。

1. 词法分析与语法分析（Lexical Analysis and Syntax Analysis）：在此阶段，Java编译器会对源代码进行词法分析和语法分析。词法分析将源代码切分成单独的词元，例如关键字、标识符、操作符、常量等。而语法分析则负责解析由词元构成的语句和结构，生成抽象语法树以描述程序结构。
2. 语义分析（Semantic Analysis）：在这个阶段中，编译器将对抽象语法树进行语义分析，检查源程序是否符合Java语言的规范和约束。它的任务包括类型检查、作用域检查、常量表达式计算、方法重载解析等。
3. 字节码生成（Bytecode Generation）：在语义分析完成后，Java编译器将使用JVM定义的字节码指令集，将Java源文件编译成Java字节码，存储为.class文件格式。Java字节码是在JVM上运行的可移植代码，它具有平台无关性，可以在任何支持Java虚拟机的平台上运行。
4. 优化（Optimization）：在生成字节码之后，Java编译器还可以对字节码进行优化处理。例如，常量折叠、循环展开、逃逸分析、调用内联等等优化手段，都可以使程序在运行时更加高效。

总的来说，Java编译过程的目标是将源代码转换为可运行的字节码，并保证其正确性和性能，以便于在JVM上执行。



问：

2023/5/19 17:16:34

java最终生成的字节码和机器码有什么不同，或者说字节码难道不是和机器码一样都是二进制码吗



答：

2023/5/19 17:17:38

Java语言生成的字节码和机器码在格式和用途上有所不同。

Java字节码是一种针对Java虚拟机（JVM）的指令集，它基于栈式架构设计，所有操作数都存储在栈中间，所有运算也都是在栈上进行的。Java编译器将Java源代码编译成字节码，并存储为.class二进制文件，这些文件可以在任何支持Java虚拟机的不同平台上执行。

而机器码则是直接在计算机硬件上运行的二进制指令集，它是与特定CPU架构密切相关的，因此不同的CPU架构需要不同的机器码。机器码通常不具有可移植性，并且很难被理解和调试。

因此，Java字节码和机器码主要有以下区别：

1. 格式不同：Java字节码是由Java编译器生成、针对Java虚拟机的特定指令集组成的二进制文件；而机器码是由汇编器或编译器生成、针对特定CPU架构的指令集，以二进制形式存储。
2. 执行方式不同：Java字节码是由Java虚拟机解释执行的，它通过跨平台的特性实现了Write Once, Run Anywhere的目标；而机器码则是由CPU直接执行的。
3. 易读性不同：Java字节码携带了更多的语义信息，因此具有一定的可读性，方便开发人员进行调试和分析；而机器码则往往是极其晦涩难懂的。

当然，Java虚拟机在解释执行Java字节码时也需要经过JIT编译等优化手段，最终生成的机器码能够有效地利用具体硬件上的各种特性来提高程序运行效率。



问

2023/5/19 17:24:11

那java程序的运行效率是不是会比c++低



答：

2023/5/19 17:25:23

Java程序相对C++程序的运行效率会略有下降，因为它们的底层机制和执行方式不同。

C++是一种本地语言，它直接编译成机器码，并以最优化的方式利用计算机内存、CPU等硬件资源，可以获得很高的性能和灵活性。C++允许开发人员使用裸机计算机的各种特性来实现底层控制，甚至可以直接嵌入汇编代码进行优化。

而Java是一种通过JVM解释执行的语言，在运行时需要先将Java字节码转换为机器码。这个过程需要额外的时间和资源，并且Java虚拟机必须经过JIT编译、垃圾回收等复杂的处理，导致Java程序的启动时间和运行效率相对较低。但是，Java也具有跨平台、安全性好、易于维护等优点，因此在某些特定场景下，它也可以取代C++等语言进行开发。

当然，对于大部分应用程序而言，由于现代计算机的性能已经足够强大，Java程序和C++程序之间的运行速度差距并不会对用户造成明显的感知。毕竟，现代计算机的瓶颈更多的是来自于网络、磁盘IO等方面，而不是CPU性能。因此，在实际开发中，选用哪种语言更多的是根据具体需求和开发人员的经验和习惯做出决策。



# 包

**导包** 

* 相同包下的类可以直接访问，不同包下的类必须导包,才可以使用！导包格式：**import 包名.类名**;

* 假如一个类中需要用到不同类，而这个两个类的名称是一样的，那么默认只能导入一个类，另一个类要带包名访问。

# 权限修饰符

权限修饰符：是用来控制一个成员能够被访问的范围。

可以修饰成员变量，方法，构造器，内部类，不同权限修饰符修饰的成员能够被访问的范围将受到限制。

权限修饰符：有四种作用范围由小到大（private -> 缺省 -> protected - > public ）

| **修饰符** | **同一个类中** | **同一个包中其他类** | **不同包下的==子类==** | **不同包下的无关类** |
| ---------- | -------------- | -------------------- | ---------------------- | -------------------- |
| private    | √              |                      |                        |                      |
| 缺省       | √              | √                    |                        |                      |
| protected  | √              | √                    | √                      |                      |
| public     | √              | √                    | √                      | √                    |

一定要注意第三个，是子类访问，只能通过子类对象访问，不能通过父类对象访问

<img src="C:\Users\痞妖\AppData\Roaming\Typora\typora-user-images\image-20230520003428059.png" alt="image-20230520003428059" style="zoom:50%;" />

# final关键字

**final的作用**

* final 关键字是最终的意思，可以修饰（类、方法、变量）

* 修饰类：表明该类是最终类，不能被继承。

* 修饰方法：表明该方法是最终方法，不能被重写。

* 修饰变量：表示该变量第一次赋值后，不能再次被赋值(有且仅能被赋值一次)

**final修饰变量的注意**

* final修饰的变量是基本类型：那么变量存储的**数据值**不能发生改变。

* final修饰的变量是引用类型：那么变量存储的**地址值**不能发生改变，但是地址指向的对象内容是可以发生变化的。



# 常量 

* 常量是使用了**public static final**修饰的成员变量，必须有初始化值，而且执行的过程中其值不能被改变。

* 常量名的命名规范：英文单词全部大写，多个单词下划线连接起来。

* 常量的作用：通常用来记录系统的配置数据。

**常量做信息配置的原理、优势**

* 在编译阶段会进行“宏替换”：把使用常量的地方全部替换成真实的字面量。

* 维护系统容易，可读性更好。

# 枚举

 修饰符 enum 枚举名称{

​      第一行都是罗列枚举类实例的名称。

}

enum Season{
   *SPRING* , *SUMMER* , *AUTUMN* , *WINTER*;
 }

# 抽象类

在Java中abstract是抽象的意思，可以修饰类、成员方法。

abstract修饰类，这个类就是抽象类；修饰方法，这个方法就是抽象方法。

**注意事项**

* **抽象方法只有方法签名**，**不能声明方法体**。

* 一个类中如果定义了抽象方法，这个类必须声明成抽象类，否则报错。

**特征和注意事项**

Ø类有的成员（成员变量、方法、构造器）抽象类都具备

Ø抽象类中不一定有抽象方法，有抽象方法的类一定是抽象类

Ø一个类继承了抽象类必须重写完抽象类的全部抽象方法，否则这个类也必须定义成抽象类。

Ø不能用abstract修饰变量、代码块、构造器。

==**最重要的特征：**得到了抽象方法，失去了创建对象的能力（**有得有失**）==



**final和abstract是什么关系？**

互斥关系

1. abstract定义的抽象类作为模板让子类继承，final定义的类不能被继承。

2. 抽象方法定义通用功能让子类重写，final定义的方法子类不能重写

# 模板方法模式

**使用场景说明**：当系统中出现同一个功能多处在开发，而该功能中大部分代码是一样的，只有其中部分可能不同的时候

**模板方法模式实现步骤**

1、定义一个抽象类。

2、定义2个方法，一个是模板方法：把相同代码放里面去，不同代码定义成抽象方法

3、子类继承抽象类，重写抽象方法。

# 接口

接口的格式如下：

**接口用关键字interface来定义**

public **interface** 接口名 {

​    // 常量

​    // 抽象方法

} 

JDK8之前接口中只能是抽象方法和常量，没有其他成分了。

接口不能实例化。

接口中的成员都是public修饰的，写不写都是，因为规范的目的是为了公开化。



> 接口是用来被类实现（implements）的，实现接口的类称为实现类。实现类可以理解成所谓的子类。
>
> 修饰符 class 实现类 implements 接口1, 接口2, 接口3 , ... {
>
> }
>
> 实现的关键字：implements
>
> 从上面可以看出，接口可以被类单实现，也可以被类多实现。

一个类实现接口，必须重写完全部接口的全部抽象方法，否则这个类需要定义成抽象类。

**接口新增的方法：**

* 默认方法
* 静态方法
* 私有方法

**接口的注意事项**

1、接口不能创建对象

2、一个类实现多个接口，多个接口的规范不能冲突

2、一个类实现多个接口，多个接口中有同样的静态方法不冲突。

3、一个类继承了父类，同时又实现了接口，父类中和接口中有同名方法，默认用父类的。

4、一个类实现了多个接口，多个接口中存在同名的默认方法，可以不冲突，这个类重写该方法即可。

5、一个接口继承多个接口，是没有问题的，如果多个接口中存在规范冲突则不能多继承。



# 多态

**多态的常见形式**

父类类型 对象名称 = new 子类构造器;

接口		 对象名称 = new 实现类构造器;

**多态的前提**

有继承/实现关系；有父类引用指向子类对象；有方法重写（**多态侧重行为多态**）。

> 产生问题：多态下不能使用子类的独有功能

* 自动类型转换（从子到父)：Animal c = **new** Cat();

* 强制类型转换（从父到子) 

**从父到子（** 必须进行强制类型转换,否则报错）: 子类 对象变量 = (子类)父类类型的变量

 **作用：可以解决多态下的劣势，可以实现调用子类独有的功能。**

 注意： 有继承/实现关系的类就可以在编译阶段进行强制类型转换；但是，如果转型后的类型和对象真实对象的类型不是同一种类型，那么在运行代码时，就会出现ClassCastException

Animal c = **new** Cat();

Dog d = (Dog)c; // 出现异常 ClassCastException

变量名 **instanceof** **真实**类型

判断关键字左边的变量指向的对象的真实类型，是否是右边的类型或者是其子类类型，是则返回true，反之。

# static关键字的理解

遇到static关键字，就知道所对应的方法或者变量都是一开始就存在的，而那些类的实例都是后来创建的，所以静态的东西都不能访问非静态的东西。因为可能不存在。



# 内部类

内部类就是定义在一个类里面的类，里面的类可以理解成（寄生），外部类可以理解成（宿主）。

public class People{
   *//* 内部类
   public class Heart{
   }
 }

* 内部类之一：静态内部类[了解]

  * 有static修饰，属于外部类本身。

  * 它的特点和使用与普通类是完全一样的，类有的成分它都有，只是位置在别人里面而已。

  * ```java
    public class Outer{
    ​    // 静态成员内部类
    ​     public static class Inner{
    ​     }
     }
    ```

    **静态内部类创建对象的格式：**  

    格式：外部类名.内部类名 对象名 = new 外部类名.内部类构造器;
    范例：`Outer.Inner in =  new Outer.Inner();`

* 内部类之二：成员内部类[了解]

  * 无static修饰，属于外部类的对象。

  * ```java
    public class Outer {
        // 成员内部类
        public class Inner {
            
        }
    }
    
    ```

    **成员内部类创建对象的格式：**  

    格式：外部类名.内部类名 对象名 = new  外部类构造器.new 内部类构造器();
    范例：`Outer.Inner in =  new Outer().new Inner();`

    注意：在成员内部类中访问所在外部类对象 ，格式：**外部类名.this。**

* 内部类之三：局部内部类[了解]（鸡肋语法，了解即可）

* 内部类之四：匿名内部类概述[重点]

# 匿名内部类

**匿名内部类产生的对象类型，相当于是当前new的那个的类型的子类类型。**

匿名内部类是一个没有名字的类

**匿名内部类一写出来，就会自己创建一个对象**

内部引用的局部变量必须是final的。在用的时候，如果一个局部变量作用范围仅仅局限于一个线程内，就会自动优化为final

```java
public class demo2 {
    public static void main(String[] args) {
        Animal a=new Animal() {
            @Override
            public void run() {
                System.out.println("老虎跑得快");
            }
        };
        a.run();
    }
}

abstract class Animal{
    public abstract  void run();
}
```



```java
public class demo2 {
    public static void main(String[] args) {
        Swimming s=new Swimming() {
            @Override
            public void swim() {
                System.out.println("学生在游泳");
            }
        };
        go(new Swimming() {//可以直接把s传入，也可以把匿名类写在内部
            @Override
            public void swim() {
                System.out.println("学生在游泳");
            }
        });
    }

    public  static void go(Swimming s){
        s.swim();
    }
}

interface Swimming{
    void swim();
}
```





# Object

| 方法名                          | 说明                                                         |
| ------------------------------- | ------------------------------------------------------------ |
| public String toString()        | 默认是返回当前对象在堆内存中的地址信息:类的全限名@内存地址   |
| public boolean equals(Object o) | 默认是比较当前对象与另一个对象的地址是否相同，相同返回true，不同返回false |

```java
    @Override
    public String toString() {
        return "demo1{" +
                "name=" + name +
                '}';
    }
```

```java
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        demo1 demo1 = (demo1) o;
        return name == demo1.name && Objects.equals(sex, demo1.sex);
    }
```

# Objects

**官方在进行字符串比较时，没有用字符串对象的的equals方法，而是选择了Objects的equals方法来比较**

```java
//这是自己写的，不是Objects中的
@Override
public boolean equals(Object o) {
    // 1、判断是否是同一个对象比较，如果是返回true。
    if (this == o) return true;
    // 2、如果o是null返回false  如果o不是学生类型返回false  ...Student !=  ..Pig
    if (o == null || this.getClass() != o.getClass()) return false;
    // 3、说明o一定是学生类型而且不为null
    Student student = (Student) o;
    return sex == student.sex && age == student.age && Objects.equals(name,student.name);
```

| 方法名                                             | 说明                                                         |
| -------------------------------------------------- | ------------------------------------------------------------ |
| public  static boolean equals(Object a,  Object b) | 比较两个对象的，底层会先进行非空判断，从而可以避免空指针异常。再进行equals比较 |
| public  static boolean isNull(Object obj)          | 判断变量是否为null  ,为null返回true  ,反之                   |

```java
public static boolean equals(Object a, Object b) {
    return (a == b) || (a != null && a.equals(b));
}//比较的结果都是一样的，但是这个更安全一点，因为里边有判断a是不是null的操作
```

# StringBuilder

**StringBuilder是一个可变的字符串的操作类，我们可以把它看成是一个对象容器**

**使用StringBuilder的核心作用：操作字符串的性能比String要更高（如拼接、修改等）**



构造方法：

| 名称                              | 说明                                           |
| --------------------------------- | ---------------------------------------------- |
| public  StringBuilder()           | 创建一个空白的可变的字符串对象，不包含任何内容 |
| public  StringBuilder(String str) | 创建一个指定字符串内容的可变字符串对象         |

常用方法：

| 方法名称                              | 说明                                                |
| ------------------------------------- | --------------------------------------------------- |
| public StringBuilder append(任意类型) | 添加数据并返回StringBuilder对象本身                 |
| public StringBuilder reverse()        | 将对象的内容反转                                    |
| public int length()                   | 返回对象内容长度                                    |
| public String toString()              | 通过toString()就可以实现把StringBuilder转换为String |



# Date

构造器：

| 名称          | 说明                                             |
| ------------- | ------------------------------------------------ |
| public Date() | 创建一个Date对象，代表的是系统当前此刻日期时间。 |

常用方法

| 名称                  | 说明                                              |
| --------------------- | ------------------------------------------------- |
| public long getTime() | 返回从1970年1月1日   00:00:00走到此刻的总的毫秒数 |

**时间毫秒值 -> 日期对象**

| 构造器                 | 说明                             |
| ---------------------- | -------------------------------- |
| public Date(long time) | 把时间毫秒值转换成Date日期对象。 |

| Date方法                       | 说明                                         |
| ------------------------------ | -------------------------------------------- |
| public void setTime(long time) | 设置日期对象的时间为当前时间毫秒值对应的时间 |

1、日期对象如何创建，如何获取时间毫秒值？

* **public Date();**

* **public long getTime**();

2、时间毫秒值怎么恢复成日期对象

* **public Date(long time);**

* **public void setTime(long time);**

# SimpleDateFormat

构造器：

| 构造器                                  | 说明                                           |
| --------------------------------------- | ---------------------------------------------- |
| public SimpleDateFormat(String pattern) | 创建简单日期格式化对象，并封装格式化的形式信息 |

格式化方法

| 格式化方法                                  | 说明                              |
| ------------------------------------------- | --------------------------------- |
| public final String **format(Date date)**   | 将日期格式化成日期/时间字符串     |
| public final String **format(Object time)** | 将时间毫秒值式化成日期/时间字符串 |



```java
        Date d = new Date();
        System.out.println(d);
        long time = d.getTime();
        //d.setTime(123);
        System.out.println(d);
        System.out.println(System.currentTimeMillis());
        SimpleDateFormat sdf = new SimpleDateFormat();//默认格式
        SimpleDateFormat sdf2 = new SimpleDateFormat("yyyy_MM_dd HH:mm:ss EEE a");
        System.out.println(sdf2.format(d));
        //字符串解析
        String dateStr="2021年08月19日 11:11:11";
        SimpleDateFormat sdf3=new SimpleDateFormat("yyyy年MM月dd日 HH:mm:ss");
        Date date=sdf3.parse(dateStr);
        System.out.println(date);//Thu Aug 19 11:11:11 CST 2021
```

# Calendar

 public abstract class Calendar：不能直接创建对象，用里边的抽象方法public static Calendar getInstance()

| 方法名                                | 说明                        |
| ------------------------------------- | --------------------------- |
| public int get(int field)             | 取日期中的某个字段信息。    |
| public void set(int field,int value)  | 修改日历的某个字段信息。    |
| public void add(int field,int amount) | 为某个字段增加/减少指定的值 |
| public final Date getTime()           | 拿到此刻日期对象。          |
| public long getTimeInMillis()         | 拿到此刻时间毫秒值          |

```java
        //创建对象
        Calendar cal =  Calendar.getInstance();
        System.out.println(cal);
        //获取日历的信息：public in get（int field）
        System.out.println(cal.get(Calendar.YEAR));
        System.out.println(cal.get(Calendar.HOUR_OF_DAY));
        //修改日历中的某个字段
        cal.set(Calendar.HOUR,4);
        System.out.println(cal.get(Calendar.HOUR));
        //为某个字段增加或减少指定值
        //64天之后是是什么时间
        cal.add(Calendar.DAY_OF_YEAR,64);
        //拿到日期对象
        Date d=cal.getTime();
        System.out.println(d);
        //拿到此时的毫秒值
        long time = cal.getTimeInMillis();
        System.out.println(time);
```

# 新增日期类

## LocalDate

```java
        //获取本地日期对象
        LocalDate nowDate = LocalDate.now();
        System.out.println("今天的日期"+nowDate);

        int year = nowDate.getYear();
        System.out.println("year:"+year);

        int mouth = nowDate.getMonthValue();
        System.out.println("mouth:"+mouth);
        //本月第几天
        int day=nowDate.getDayOfMonth();
        System.out.println("day:"+day);
        //本年第几天
        int dayOfYear = nowDate.getDayOfYear();
        System.out.println("dayOfYear:"+dayOfYear);
        //星期
        System.out.println(nowDate.getDayOfWeek());//显示英文的星期几  TUESDAY
        System.out.println(nowDate.getDayOfWeek().getValue());//显示数字  2
        //月份
        System.out.println(nowDate.getMonth());//同上
        System.out.println(nowDate.getMonth().getValue());//和上边的getMouthValue效果一样。

        System.out.println("-----------------");
        LocalDate ld = LocalDate.of(1991,10,1);
        System.out.println(ld);
        System.out.println(LocalDate.of(2021,6,7));
```

## LocalTime

```java
        //获取本地时间对象
        LocalTime nowTime = LocalTime.now();
        System.out.println("今天的时间："+nowTime);//13:32:16.198704200
        //时
        int hour=nowTime.getHour();
        System.out.println("hour:"+hour);//13
        //分
        System.out.println("minute:"+nowTime.getMinute());//32
        //秒
        System.out.println("second:"+nowTime.getSecond());//16
        //纳秒
        System.out.println("nano"+nowTime.getNano());//198704200

        System.out.println("---------------------");
        System.out.println(LocalTime.of(2,50));//时分
        System.out.println(LocalTime.of(2,50,20));//时分秒
        System.out.println(LocalTime.of(2,50,20,90));//时分秒纳秒
        LocalTime mTime = LocalTime.of(2,30);//返回的是LocalTime的对象

        
```

## LocalDateTime

和上边两个的API基本一致

## 常用操作API

新API的类型几乎全部是不变类型（和String的使用类似），可以放心使用不必担心被修改。

```java
    	LocalDateTime nowDateTime=LocalDateTime.now();
        //LocalDateTime向LocalDate和LocalTime转化的API
        LocalDate ld = nowDateTime.toLocalDate();
        LocalTime lt = nowDateTime.toLocalTime();
        System.out.println("----------------------");
        System.out.println(lt);
        System.out.println(lt.minusHours(1));//一小时前
        System.out.println(lt.minusMinutes(1));//一分钟前
        System.out.println(lt.minusSeconds(1));//一秒前
        System.out.println(lt.minusNanos(1));//一纳秒前
        System.out.println("----------------------");
        System.out.println(lt);
        System.out.println(lt.plusHours(1));//一小时后
        System.out.println(lt.plusMinutes(1));//一分钟后
        System.out.println(lt.plusSeconds(1));//一秒后
        System.out.println(lt.plusNanos(1));//一纳秒后
        System.out.println("----------------------");
        System.out.println(lt);//可以看到lt的值是始终不变的，每次操作都产生一个新对象

```

这些方法返回的是一个新的实例引用，因为LocalDateTime 、LocalDate 、LocalTime 都是不可变的。

## 比较操作：

```java
LocalDate birDate = LocalDate.of(2003,8,19);
LocalDate nowDate = LocalDate.now();
System.out.println("今天是2003年8月19日吗？"+nowDate.equals(birDate));
System.out.println(nowDate+"是在"+birDate+"之前？"+nowDate.isBefore(birDate));
System.out.println(nowDate+"是在"+birDate+"之后？"+nowDate.isAfter(birDate));
System.out.println("判断今天是不是生日");
MonthDay birMd=MonthDay.of(birDate.getMonth().getValue(),birDate.getDayOfMonth());
MonthDay nowMd=MonthDay.from(nowDate);//有两种转换为MonthDay的方法
System.out.println("今天是你的生日吗？"+birMd.equals(nowMd));
            
```

## Instant

```java
        //得到一个Instant时间戳对象
        Instant instant = Instant.now();
        System.out.println(instant);//这是世界标准时间，不是北京时间
        //如何得到系统此刻的时间戳
        Instant instant1=Instant.now();
        System.out.println(instant1.atZone(ZoneId.systemDefault()));
        //如何返回Date对象
        Date date=Date.from(instant);
        System.out.println(date);
        //相互转化
        Instant i2=date.toInstant();
        System.out.println(i2);
```

## DateTimeFormatter

正反都能调用format方法。

```java
        LocalDateTime ldt = LocalDateTime.now();
        System.out.println(ldt);
        //解析/格式化器
        DateTimeFormatter dtf=DateTimeFormatter.ofPattern("yyyy_MM_dd HH:mm:ss EEE a");
        //正向格式化
        String ldtStr1=dtf.format(ldt);
        System.out.println(ldtStr1);
        //逆向格式化
        String ldtStr = ldt.format(dtf);
        System.out.println(ldtStr);
        //解析字符串时间
        DateTimeFormatter dft1=DateTimeFormatter.ofPattern("yyyy_MM_dd HH:mm:ss");
        String dateStr ="2018_06_07 11:30:30";//这里一定要注意只有个位数要在前边写0,6月份就写06，否则报错
        //解析字符串为本地日期时间
        LocalDateTime ldt1=LocalDateTime.parse(dateStr,dft1);
        System.out.println(ldt1);
        
```



## ⚠Duration/Period

**Period**

在Java8中，我们可以使用以下类来计算**日期间隔**差异：java.time.Period

**主要是 Period 类方法 getYears()，getMonths() 和 getDays() 来计算,只能精确到年月日。**

**用于 LocalDate 之间的比较。**

```java
LocalDate today = LocalDate.now();
System.out.println(today);
LocalDate birthDate = LocalDate.of(2003, 8, 19);
System.out.println(birthDate); // 1995-01-11

Period period = Period.between(birthDate, today);//获取两个时间的差，第二个参数-第一个参数

System.out.printf("年龄 : %d 年 %d 月 %d 日", period.getYears(), period.getMonths(), 		period.getDays());

```



**Duration**

在Java8中，我们可以使用以下类来计算时间间隔差异：java.time.Duration

提供了使用基于时间的值测量时间量的方法。

**用于 LocalDateTime 之间的比较。也可用于 Instant 之间的比较。**

```java
LocalDateTime today = LocalDateTime.now();
System.out.println(today);
LocalDateTime birthDate = LocalDateTime.of(1990,10,1,10,50,30);
System.out.println(birthDate);

Duration duration = Duration.between(birthDate, today);//第二个参数减第一个参数
System.out.println(duration.toDays());//两个时间差的天数
System.out.println(duration.toHours());//两个时间差的小时数
System.out.println(duration.toMinutes());//两个时间差的分钟数
System.out.println(duration.toMillis());//两个时间差的毫秒数
System.out.println(duration.toNanos());//两个时间差的纳秒数

```

## **java.time.temporal.ChronoUnit**

**ChronoUnit类可用于在单个时间单位内测量一段时间，这个工具类是最全的了，可以用于比较所有的时间单位**

```java
LocalDateTime today = LocalDateTime.now();
System.out.println(today);
LocalDateTime birthDate = LocalDateTime.of(1990,10,1,10,50,30);
System.out.println(birthDate);

System.out.println("相差的年数：" + ChronoUnit.YEARS.between(birthDate, today));//参数类型需要一致。
System.out.println("相差的月数：" + ChronoUnit.MONTHS.between(birthDate, today));
System.out.println("相差的周数：" + ChronoUnit.WEEKS.between(birthDate, today));
System.out.println("相差的天数：" + ChronoUnit.DAYS.between(birthDate, today));
System.out.println("相差的时数：" + ChronoUnit.HOURS.between(birthDate, today));
System.out.println("相差的分数：" + ChronoUnit.MINUTES.between(birthDate, today));
System.out.println("相差的秒数：" + ChronoUnit.SECONDS.between(birthDate, today));
System.out.println("相差的毫秒数：" + ChronoUnit.MILLIS.between(birthDate, today));
System.out.println("相差的微秒数：" + ChronoUnit.MICROS.between(birthDate, today));
System.out.println("相差的纳秒数：" + ChronoUnit.NANOS.between(birthDate, today));

System.out.println("相差的半天数：" + ChronoUnit.HALF_DAYS.between(birthDate, today));
System.out.println("相差的十年数：" + ChronoUnit.DECADES.between(birthDate, today));
System.out.println("相差的世纪（百年）数：" + ChronoUnit.CENTURIES.between(birthDate, today));
System.out.println("相差的千年数：" + ChronoUnit.MILLENNIA.between(birthDate, today));
System.out.println("相差的纪元数：" + ChronoUnit.ERAS.between(birthDate, today));

```

# 包装类

**实现了一切皆对象。**

**后期集合和泛型不支持基本类型，只能使用包装类。**

其实就是8种基本数据类型对应的引用类型。

| 基本数据类型 | 引用数据类型 |
| ------------ | ------------ |
| byte         | Byte         |
| short        | Short        |
| int          | Integer      |
| long         | Long         |
| char         | Character    |
| float        | Float        |
| double       | Double       |
| boolean      | Boolean      |

**自动装箱**：基本类型的数据和变量可以直接赋值给包装类型的变量。

**自动拆箱：**包装类型的变量可以直接赋值给基本数据类型的变量。

* 包装类的变量的默认值可以是null，容错率更高。

* 可以把基本类型的数据转换成字符串类型(用处不大)

* **可以把字符串类型的数值转换成真实的数据类型（真的很有用）**

```java
        //int a=Integer.parseInt("23");
        int a=Integer.valueOf("23");//两个效果一样，建议用下边这个，因为函数名称统一，优雅
        System.out.println(a);//23
		
		//要注意，转化的字符串一定是对应的类型，“23.3”转化为int就报错，“23.a”也是报错
        
		//double b=Double.parseDouble("99.9");
        double b=Double.valueOf("99.9");
        System.out.println(b);//99.9
```

# 正则表达式

**用一些规定的字符来制定规则，来检验数据格式的合法性**

## 初体验

检查qq号的合法性：全是数字，长度在6和20之间

```java
package regex;

import java.util.Scanner;

public class demo1 {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        System.out.println(checkQQ("1234a56789"));
    }
    public static boolean checkQQ(String QQ){
        if(QQ==null||QQ.length()<6||QQ.length()>20){
            return false;
        }
        for (int i = 0; i < QQ.length(); i++) {
            if (QQ.charAt(i)<'0'||QQ.charAt(i)>'9'){
                return false;
            }
        }
        return true;
    }
    static public boolean checkQQ2(String qq){//正则表达式
        return qq!=null&&qq.matches("\\d{6,20}");
    }
}

```

![image-20230524192504363](C:\Users\痞妖\AppData\Roaming\Typora\typora-user-images\image-20230524192504363.png)



> 单词字符指的是数字+字母+下划线

| 方法名                                               | 说明                                                         |
| ---------------------------------------------------- | ------------------------------------------------------------ |
| public String replaceAll(String regex,String newStr) | 按照正则表达式匹配的内容进行替换                             |
| public String[] split(String regex)：                | 按照正则表达式匹配的内容进行分割字符串，反回一个字符串数组。 |

```java
        String str="sdasd得到sdasd大声道sad萨达";
        String[] s=str.split("\\w+");//按照正则表达式匹配的内容进行分割字符串，反回一个字符串数组。 
        for (int i = 0; i < s.length; i++) {
            System.out.println(s[i]);
        }
        System.out.println(str.replaceAll("\\w+", "%20"));//按照正则表达式匹配的内容进行替换

```



## 利用正则表达式爬取数据

```java
        String rs="来黑马程序员学习java，电话020-43422424，或者；联系邮箱"+
                "itcast@itcast.cn,电话18762832633";
        //需求从上面的内容爬取出 电话号码和邮箱。

        //1.定义爬取规则
        String regex="(\\w{1,}@\\w{2,10}(\\.\\w{2,10}){1,2})|"+
                "(1[3-9]\\d{9})|(0\\d{2,5}-?\\d{5,15})|400-?\\d{3,8}-?\\d{3,8}";

        //2.编译正则表达式成为一个匹配规则对象
        Pattern pattern = Pattern.compile((regex));

        //3.通过匹配规则对象得到一个匹配数据内容的匹配器对象
        Matcher matcher = pattern.matcher(rs);

        //4.通过匹配器去内容中爬取信息
        while(matcher.find()){
            System.out.println(matcher.group());
        }
```



# Arrays类

**数组操作工具类，专门用于操作数组元素的。**

Arrays是个工具类，里边封装的都是静态方法，所以只需要用类名直接调用里边的函数。

```java
        int[] arr={1,9,54,65,20};
        //1.返回数组中的内容
        System.out.println(arr);//直接输出返回的是数组地址
        System.out.println(Arrays.toString(arr));

        //2.排序的API（默认自动对数组元素进行升序排序）
        Arrays.sort(arr);
        System.out.println(Arrays.toString(arr));

        //3.二分搜索技术(前提是数组有序)
        int index = Arrays.binarySearch(arr,20);
        System.out.println(index);//2

        //如果元素不存在，返回 -（应该插入的位置 + 1）
        int index2=Arrays.binarySearch(arr,90);
        System.out.println(index2);//-6
```

## 自定义数组排序规则

```java
        //1.默认排序
        int[] arr={1,9,54,65,20};
        Arrays.sort(arr);//默认升序
        System.out.println(Arrays.toString(arr));//[1, 9, 20, 54, 65]

        //2.自定义比较器对象，只支持引用类型的排序
        Integer[] arr2={1,9,54,65,20};
        Arrays.sort(arr2,new Comparator<Integer>(){
            @Override
            public int compare(Integer o1, Integer o2) {
                //返回值大于零就交换
                return o2-o1;
            }
        });
        System.out.println(Arrays.toString(arr2));//[65, 54, 20, 9, 1]
```

## 自定义类型排序

**要注意如果要比较的是浮点数类型，就不能直接加减，要用Double里边封装的compare函数**

```java
package regex;

import java.util.Arrays;
import java.util.Comparator;
import java.util.Scanner;

public class demo1 {
    public static void main(String[] args) {
        //1.默认排序
        int[] arr={1,9,54,65,20};
        Arrays.sort(arr);//默认升序
        System.out.println(Arrays.toString(arr));//[1, 9, 20, 54, 65]

        //2.自定义比较器对象，只支持引用类型的排序
        Integer[] arr2={1,9,54,65,20};
        Arrays.sort(arr2,new Comparator<Integer>(){
            @Override
            public int compare(Integer o1, Integer o2) {
                return o2-o1;
            }
        });
        System.out.println(Arrays.toString(arr2));//[65, 54, 20, 9, 1]

        //自定义类型排序
        Student[] s={new Student(20,"sad",1),new Student(18,"sd",0),new Student(19,"sad",1)};
        Arrays.sort(s, new Comparator<Student>() {
            @Override
            public int compare(Student o1, Student o2) {
                return o1.age-o2.age;
            }
        });
        System.out.println(Arrays.toString(s));

        //
        Student[] s2={new Student(20,"sad",180.5),new Student(18,"sd",190),new Student(19,"sad",175.5)};
        Arrays.sort(s2, new Comparator<Student>() {
            @Override
            public int compare(Student o1, Student o2) {
                return Double.compare(o1.height,o2.height);//如果直接进行强制类型转化，就会造成精度损失，所以要么用if 语句，要么调用函数
            }
        });
        System.out.println(Arrays.toString(s2));
    }
}
class Student{
    int age;
    String name;
    double height;

    public Student() {
    }

    public Student(int age, String name, double height) {
        this.age = age;
        this.name = name;
        this.height = height;
    }


    public String toString() {
        return "Student{age = " + age + ", name = " + name + ", height = " + height + "}";
    }
}

```

 # Lambda

**简化内部类的代码写法**

**Lambda表达式只能函数式接口的匿名内部类的写法形式**

函数式接口：

* 必须是**接口**，并且接口中只**能有一个抽象方法**的形式
* 在接口加一个@Functionallnterface注解，标记该接口必须满足函数式接口（**即只有一个抽象方法**）

```java
 package LambdaAmo;
/*(匿名内部类被重写方法的形参列表) -> {
    被重写方法的方法体代码。
}
注：-> 是语法形式，无实际含义*/

public class demo1 {
    public static void main(String[] args) {
        Swimming s = new Swimming() {
            @Override
            public void swim() {
                System.out.println("老师游泳游得快");
            }
        };
        Swimming s1 = () -> {
            System.out.println("老师游得快");
        };
        go(s1);

        //更简化
        go(() -> {
            System.out.println("学生游得快");
        });
    }

    public static void go(Swimming s) {
        System.out.println("开始游泳");
        s.swim();
        System.out.println("结束运动");
    }
}

@FunctionalInterface//说明这是个函数式接口
interface Swimming {
    void swim();
}

```

```java
//自定义排序
//使用的Lambda表达式简化Comparator接口的匿名形势
        Integer[] arr3={1,9,54,65,20};
        Arrays.sort(arr3,(Integer o1, Integer o2)->{
                return o2-o1;
        });
        System.out.println(Arrays.toString(arr3));//[65, 54, 20, 9, 1]

```

# Lambda进一步简化规则

**Lambda表达式的省略写法（进一步在Lambda表达式的基础上继续简化）**

* **参数类型可以省略不写**。

* 如果**只有一个参数**，参数类型可以省略，同时()也可以省略。

* 如果Lambda表达式的方法体代码**只有一行代码**。可以省略大括号不写,**同时要省略分号**！

* 如果Lambda表达式的方法体代码**只有一行代码**。可以省略大括号不写。此时，如果这行代码是return语句，**必须省略return不写**，同时也必须省略";"不写

```java
//        Arrays.sort(arr3,(Integer o1, Integer o2)->{
//                return o2-o1;
//        });
//jian'hua
        Arrays.sort(arr3,( o1,  o2)->o2-o1);
```



# 集合Collection

![image-20230529000343324](C:\Users\痞妖\AppData\Roaming\Typora\typora-user-images\image-20230529000343324.png)

```java
        //有序 可重复 有索引
        Collection list = new ArrayList();//多态的写法
        list.add("java");
        list.add("java");
        list.add(23);
        list.add(23);
        list.add("Mybatis");
        list.add(false);
        list.add(false);
        System.out.println(list);//[java, java, 23, 23, Mybatis, false, false]

        //无序 不重复 无索引
        Collection list1=new HashSet();//多态的写法
        list1.add("java");
        list1.add("java");
        list1.add(23);
        list1.add(23);
        list1.add("Mybatis");
        list1.add(false);
        list1.add(false);
        System.out.println(list1);//[java, false, 23, Mybatis]

```

## 对泛型的支持

只支持引用数据类型，不支持基本数据类型，集合中存储的元素都是对象

存储基本类型，要使用包装类

```java
   		Collection<String> list3=new ArrayList<>();
        //list3.add(23);//报错
        list3.add("hello world");

        //集合和泛型都只支持引用数据类型
        //Collection<int> list4=new ArrayList<>();//报错
        Collection<Integer> list4=new ArrayList<>();
    
```

## Collection的常用API

| 方法名称                             | 说明                             |
| ------------------------------------ | -------------------------------- |
| public  boolean add(E e)             | 把给定的对象添加到当前集合中     |
| public  void clear()                 | 清空集合中所有的元素             |
| public  boolean remove(E e)          | 把给定的对象在当前集合中删除     |
| public  boolean contains(Object obj) | 判断当前集合中是否包含给定的对象 |
| public  boolean isEmpty()            | 判断当前集合是否为空             |
| public  int size()                   | 返回集合中元素的个数。           |
| public  Object[] toArray()           | 把集合中的元素，存储到数组中     |

**紧接上边的list和list1操作**

```java
    //list是ArrayList  list1是HashSet

        //1.添加元素，成功返回true
        System.out.println(list.add(23));//ArrayList总能成功，因为允许重复
        System.out.println(list1.add("java"));

        //2.清空集合元素
        //list.clear();
        //System.out.println(list);

        //3.判断是否为空
        System.out.println(list.isEmpty());//false

        //4.获取集合的大小
        System.out.println(list.size());

        //5.判断集合中是否包含某个元素
        System.out.println(list.contains("java"));

        //6.删除某个元素，如果有多个重复的元素，默认删除第一个
        System.out.println(list.remove("java"));//true
        System.out.println(list.remove("cpp"));//false
        System.out.println(list);

        //7.把集合转化为数组,//这里要用Object，因为就算有泛型支持，也会有其他方法添加其他类型的数据
        Object[] arrs=list.toArray();//这个函数返回的就是Object，如果想直接拿特定的类型的数组，需要强制类型转化，父类到子类是强制转换，子类到父类是隐式转换
        
		//Collection<Integer> c=new ArrayList<>();
        //Integer[] i= (Integer[]) c.toArray();
        System.out.println(Arrays.toString(arrs));

        //8.合并两个集合
        Collection<String> c1=new ArrayList<>();
        c1.add("jack");
        c1.add("jay");
        Collection<String> c2=new ArrayList<>();
        c2.add("五月天");
        c2.add("周杰伦");
        c1.addAll(c2);
        System.out.println(c1);//[jack, jay, 五月天, 周杰伦]
        System.out.println(c2);//[五月天, 周杰伦]   第二个集合的元素并没有发生改变

```

## 集合的遍历方式

### 迭代器

| 方法名称                        | 说明                                                        |
| ------------------------------- | ----------------------------------------------------------- |
| **Iterator<E>**  **iterator()** | 返回集合中的迭代器对象，该迭代器对象默认指向当前集合的0索引 |

| 方法名称          | 说明                                                         |
| ----------------- | ------------------------------------------------------------ |
| boolean hasNext() | 询问当前位置是否有元素存在，存在返回true ,不存在返回false    |
| E  next()         | 获取当前位置的元素，并同时将迭代器对象移向下一个位置，注意防止取出越界。 |



```java
        Collection<String> c=new ArrayList<>();
        c.add("氢氦锂铍硼");
        c.add("碳氮氧氟氖");
        c.add("钠镁铝硅磷");
        c.add("硫氯氩钾钙");
        //1.得到当前集合的迭代器对象
        Iterator<String> it= c.iterator();
        //next()会返回当前元素，并移动到下一个元素的位置
        //这种遍历方式不是最好的，因为一旦多写一个就会越界报错
//        System.out.println(it.next());
//        System.out.println(it.next());
//        System.out.println(it.next());
//        System.out.println(it.next());

        //2.定义while循环
        while(it.hasNext()){//先判断该位置是不是有元素存在
            System.out.println(it.next());
        }
```

### 增强for循环 foreach

```java
        for (String s : c) {
            System.out.println(s);
        }
```

### Lambda

```java
        c.forEach(new Consumer<String>() {
            @Override
            public void accept(String s) {
                System.out.println(s);
            }
        });
        //lambda表达式
        c.forEach(s-> System.out.println(s));
        //进一步简化
        c.forEach(System.out::println);
```

### 集合存储自定义类型

集合存储的是元素对象的地址



# List系列集合

* ArrayList、LinekdList ：有序，可重复，有索引。

* 有序：存储和取出的元素顺序一致

* **有索引**：可以通过索引操作元素

* 可重复：存储的元素可以重复

==**List集合因为支持索引，所以多了很多索引操作的独特api，其他Collection的功能List也都继承了**==

| 方法名称                       | 说明                                   |
| ------------------------------ | -------------------------------------- |
| void add(int  index,E element) | 在此集合中的指定位置插入指定的元素     |
| E remove(int  index)           | 删除指定索引处的元素，返回被删除的元素 |
| E set(int index,E  element)    | 修改指定索引处的元素，返回被修改的元素 |
| E get(int  index)              | 返回指定索引处的元素                   |

```java
        //1.创建一个ArrayList集合对象
        //List：有序，可重复，有索引的
        List<String> list=new ArrayList<>();//经典代码，使用多态，既可以使用集合的方法，又可以使用List的独有方法,所以用List不用Collection实现多态
        list.add("氢氦锂铍硼");
        list.add("碳氮氧氟氖");
        list.add("钠镁铝硅磷");
        list.add("硫氯氩钾钙");
        System.out.println(list);

        //2.在某个索引位置插入元素
        list.add(2,"化学方程式");
        System.out.println(list);

        //3.根据索引删除元素，返回被删除的元素
        System.out.println(list.remove(2));

        //4.根据索引获取元素
        System.out.println(list.get(2));

        //5.返回索引位置处的元素，返回修改之前的元素
        System.out.println(list.set(2,"忘了"));
        System.out.println(list);
```

## List的独有遍历方式

```java
        for (int i = 0; i < list.size(); i++) {
            System.out.println(list.get(i));
        }//就是通过最简单的for循环
```

## ArrayList集合底层原理

* ArrayList底层是基于数组实现的：根据索引定位元素快，增删需要做元素的移位操作。

* 第一次创建集合并添加第一个元素的时候，在底层创建一个默认长度为10的数组。

## LinkedList的独有方法，首尾操作

| 方法名称                   | 说明                             |
| -------------------------- | -------------------------------- |
| public  void addFirst(E e) | 在该列表开头插入指定的元素       |
| public  void addLast(E e)  | 将指定的元素追加到此列表的末尾   |
| public  E getFirst()       | 返回此列表中的第一个元素         |
| public  E getLast()        | 返回此列表中的最后一个元素       |
| public  E removeFirst()    | 从此列表中删除并返回第一个元素   |
| public  E removeLast()     | 从此列表中删除并返回最后一个元素 |

**因为是独有的，所以就不用多态写法**



## 集合的并发修改异常问题

```java
        List<String> list = new ArrayList<>();
        list.add("赵敏");
        list.add("王刚");
        list.add("铁蛋");
        list.add("刚子");
        list.add("蚂蚱");
        Iterator<String> it = list.iterator();
        //当我们从集合中找出某个元素并删除的时候可能出现一种并发修改异常问题。
        while (it.hasNext()) {
            String s = it.next();
            if ("铁蛋".equals(s))
                //list.remove("铁蛋");//报错删除了铁蛋之后，指针原本是指向刚子的，但是又因为元素前移，指向了蚂蚱
                it.remove();//内部先做一个it--操作，然后再删除元素，并且不会后移
            System.out.println(list);
        }
```

![image-20230527173050061](C:\Users\痞妖\AppData\Roaming\Typora\typora-user-images\image-20230527173050061.png)

# 泛型

## 自定义泛型类

原理：**把出现泛型变量的地方全部替换成传输的真实数据类型**

```java
public class MyList<E> {
    private ArrayList<E> list = new ArrayList<>();
    public void add(E a){
        list.add(a);
    }
    public void remove(E a){
        list.add(a); 
    }
}
```



## 自定义泛型类中的静态方法

public static<T>  T test(){

}

问题在于为什么自定义泛型类明明已经声明了T，但是在写静态方法时，为什么还要再声明一遍T。

对于声明了<T>的类(Test1<T>就是声明了<T>的类)不需要声明泛型方法,**对于带了static的方法,它并不属于类的一部分,所以相当于没有声明<T>的类,所以需要声明为泛型方法.**

[参考资料](https://blog.csdn.net/q610376681/article/details/88542620)

## 自定义泛型方法

**泛型方法的格式：修饰符 <泛型变量> 方法返回值 方法名称(形参列表){}**

```java
    public static void main(String[] args) {
        Integer[] arr={1,2,3,4};
        toS(arr);
    }
    public static  <T> void toS(T[] arr){
        for (int i = 0; i < arr.length; i++) {
            System.out.println(arr[i]+" ");
        }
    }
```

## 自定义泛型接口

`public interface Data<E>{}`

## 泛型通配符、上下限

? 在使用泛型时，代表一切类型

**要注意一点，一个Father两个Son1，Son2，他们之间是父子关系，但是ArrayList\<Father>和ArrayList\<Son1>和ArrayList\<Son2>，不是父子关系。**

**泛型的上下限**

* **? extends Car:    ?必须是Car或者其子类  泛型上限**

* **？super Car ： ?必须是Car或者其父类  泛型下限**

```java
import java.util.ArrayList;

public class Test {
    public static void main(String[] args) {
        ArrayList<BENZ> benz=new ArrayList<>();
        benz.add(new BENZ());
        benz.add(new BENZ());
        benz.add(new BENZ());
        go(benz);
        
        ArrayList<BMW> bmw=new ArrayList<>();
        bmw.add(new BMW());
        bmw.add(new BMW());
        bmw.add(new BMW());
        go(bmw);
        
        ArrayList<Dog> dog=new ArrayList<>();
        dog.add(new Dog());
        dog.add(new Dog());
        //go(dog);//报错
    }
    public static void go(ArrayList<? extends Car> arr){//通配符
    }

}
class BENZ extends Car{
}
class BMW extends Car{
}
abstract class Car{
}
class Dog{
}

```



# Set

无序，无重复，无索引

**Set集合实现类特点**

* HashSet : 无序、不重复、无索引。

* LinkedHashSet：**有序**、不重复、无索引。

* TreeSet：**排序**、不重复、无索引。

```java
   //看看set系列集合的特点：HashSet LinkedHashSet TreeSet
    public static void main(String[] args) {
        Set<String> sets=new HashSet<>();
        sets.add("Java");
        sets.add("Cpp");
        sets.add("Python");
        sets.add("HTML");
        sets.add("Golang");
        sets.add("PHP");
        System.out.println(sets);
        //输出：
        //HashSet：[Golang, Java, Cpp, PHP, HTML, Python]
        //LinkedHashSet：[Java, Cpp, Python, HTML, Golang, PHP]
        //TreeSet：[Cpp, Golang, HTML, Java, PHP, Python]
    }
```

## 哈希表

**是根据对象的地址值去得到对应的哈希值，和c++中学的不一样**

Object类中的API

```java
public int hashCode(); //返回对象的哈希值
String name="hello";
System.out.println(name.hashCode());
```

* 底层结构：哈希表（数组、链表、红黑树的结合体）

* 当挂在元素下面的数据过多时，查询性能降低，从JDK8开始后，**当链表长度超过8的时候，自动转换为红黑树。**



① 创建一个**默认长度16**，默认加载因为0.75的数组，数组名table

② **根据元素的哈希值跟数组的长度计算出应存入的位置**

③ 判断当前位置是否为null，如果是null直接存入，如果位置不为null，表示有元素， 则调用equals方法比较属性值，如果一样，则不存，如果不一样，则存入数组。

④ 当数组存满到16\*0.75=12时，就自动扩容**，**每次扩容原先的两倍

## HashSet去重原理

**HashSet去重的原理：先判断哈希值，再调用equals，所以有的自定义类型，如果不重写equals方法，那么就会出错，默认比较地址值。所以要重写equals方法**

==一定要重写hashCode和equals方法，因为两个成员变量相等的自定义类型的对象，如果只重写了equals，那么两个对象的地址不同，对应的hash值还是不同，最后也不会判断是否相等，只重写hashCode那么，两个对象相等的对应的hash值相等，但是判断相等时，默认判断的是地址想不想等。==

```java
package demo1;

import java.util.*;

public class SET {
    //看看set系列集合的特点：HashSet LinkedHashSet TreeSet
    public static void main(String[] args) {
        Student s1=new Student("Sam",20,'男');
        Student s2=new Student("Sam",20,'男');
        Student s3=new Student("Tom",21,'女');
        System.out.println(s1.hashCode());
        System.out.println(s2.hashCode());
        System.out.println(s3.hashCode());
        
        Set<Student> sets=new HashSet<>();
        sets.add(s1);
        sets.add(s2);
        sets.add(s3);

        System.out.println(sets);
    }
}
class Student{
    String name;
    int age;
    char sex;

    public Student(String name, int age, char sex) {
        this.name = name;
        this.age = age;
        this.sex = sex;
    }
    public Student(){
    }

    @Override
    public String toString() {
        return "Student{" +
                "name='" + name + '\'' +
                ", age=" + age +
                ", sex=" + sex +
                '}';
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Student student = (Student) o;
        return age == student.age && sex == student.sex && Objects.equals(name, student.name);
    }

    @Override
    public int hashCode() {
        return Objects.hash(name, age, sex);
    }
}

```

## LinkedHashSet

<img src="C:\Users\痞妖\AppData\Roaming\Typora\typora-user-images\image-20230528115348010.png" alt="image-20230528115348010" style="zoom: 33%;" />

**底层数据结构是依然哈希表，只是每个元素又额外的多了一个双链表的机制记录存储的顺序，所以是有序的**

## TreeSet

* 不重复、无索引、可排序

* 可排序：按照元素的大小默认升序（有小到大）排序。

* TreeSet集合底层是基于红黑树的数据结构实现排序的，增删改查性能都较好。

* **注意：TreeSet集合是一定要排序的，==可以将元素按照指定的规则进行排序。==**

**结论：想要使用TreeSet存储自定义类型，需要制定排序规则**

![image-20230528145007981](C:\Users\痞妖\AppData\Roaming\Typora\typora-user-images\image-20230528145007981.png)

```java
package demo1;

public class Apple implements Comparable<Apple> {
    int price;
    double weight;
    @Override
    public String toString() {
        return "Apple{" +
                "price=" + price +
                ", weight=" + weight +
                '}';
    }

    @Override
    public int compareTo(Apple o) {
        return Double.compare(this.weight,o.weight);
    }
}

```



# 可变参数

用在形参中，可以接受多个数据

格式：数据类型... 参数名称

**作用：传参灵活，方便，可以不传参数，可以传一个或多个，也可以传数组	**

**一个形参列表中只能有一个可变参数，可变参数必须放在形参列表最后面**

```java
public class demo {
    public static void main(String[] args) {
        sum();//0 []
        sum(10, 20, 30);//3 [10, 20, 30]
        sum(new int[]{10, 20, 30, 40, 50});//5 [10, 20, 30, 40, 50]
    }
    //一个形参列表中只能有一个可变参数，可变参数必须放在形参列表最后面
    public static void sum(int... a) {
        //可变参数在方法内部就是一个数组
        System.out.println(a.length + " " + Arrays.toString(a));
    }
}
```

# 集合工具类Collections

| 方法名称                                                     | 说明                         |
| ------------------------------------------------------------ | ---------------------------- |
| public static <T> boolean  addAll(Collection<? super T> c, T... elements) | 给集合对象批量添加元素       |
| public static void shuffle(List<?> list)                     | 打乱List集合元素的顺序       |
| public static <T> void sort(List<T> list)                    | 将集合中元素按照默认规则排序 |
| public static <T> void sort(List<T> list，Comparator<? super T> c) | 将集合中元素按照指定规则排序 |

```java
        List<Apple> apples = new ArrayList<>();
        Collections.addAll(apples,new Apple(10,20),new Apple(12,10),new Apple(12,10.5)
        ,new Apple(11,13.5));

        //Collection.sort(apples) 方式一
        Collections.sort(apples);
        System.out.println(apples);

        //方式二，sort方法自带比较器对象
//        Collections.sort(apples, new Comparator<Apple>() {
//            @Override
//            public int compare(Apple o1, Apple o2) {
//                return o1.price-o2.price;
//            }
//        });
        Collections.sort(apples, (o1, o2)->o1.price-o2.price);
        System.out.println(apples);

        Collections.shuffle(apples);
        System.out.println(apples);
```

# map

* Map集合是一种双列集合，每个元素包含两个数据。

* Map集合的每个元素的格式：key=value(键值对元素)。

* Map集合也被称为“**键值对集合**”。

**Map集合的整体格式**

* Collection集合的格式: [元素1,元素2,元素3..]

* Map集合的完整格式：{key1=value1 , key2=value2 , key3=value3 , ...}

![image-20230529000458087](C:\Users\痞妖\AppData\Roaming\Typora\typora-user-images\image-20230529000458087.png)



**Map体系结构的特点**

* **Map集合的特点都是由键决定的。**

* **Map集合的键是无序,不重复的，无索引的，值不做要求**（可以重复）。

* Map集合后面重复的键对应的值会覆盖前面重复键的值。

* Map集合的键值对都可以为null。



**Map的实现类特点**

* HashMap:元素按照键是无序，不重复，无索引，值不做要求。（与Map体系一致）

* LinkedHashMap:元素按照键是**有序**，不重复，无索引，值不做要求。

* TreeMap：元素按照建是**排序**，不重复，无索引的，值不做要求。

```java
        //创建一个Map集合对象
        Map<String,Integer> maps=new HashMap<>();
        maps.put("鸿星尔克",3);
        maps.put("Java",1);
        maps.put("枸杞",10);
        maps.put("Java",100);//覆盖前面的值
        maps.put(null,null); //Map集合的键值对可以为null
        System.out.println(maps);//无序
```

```java
        //创建一个Map集合对象
        Map<String,Integer> maps=new LinkedHashMap<>();
        maps.put("鸿星尔克",3);
        maps.put("Java",1);
        maps.put("枸杞",10);
        maps.put("Java",100);//覆盖前面的值
        maps.put(null,null); //Map集合的键值对可以为null
        System.out.println(maps);//有序
```

## Map集合的常用API

| 方法名称                            | 说明                                 |
| ----------------------------------- | ------------------------------------ |
| V  put(K key,V value)               | 添加元素                             |
| V  remove(Object key)               | 根据键删除键值对元素                 |
| void  clear()                       | 移除所有的键值对元素                 |
| boolean containsKey(Object key)     | 判断集合是否包含指定的键             |
| boolean containsValue(Object value) | 判断集合是否包含指定的值             |
| boolean isEmpty()                   | 判断集合是否为空                     |
| int  size()                         | 集合的长度，也就是集合中键值对的个数 |

```java
        //创建一个Map集合对象
        Map<String,Integer> maps=new HashMap<>();
        maps.put("鸿星尔克",3);
        maps.put("Java",1);
        maps.put("枸杞",10);
        maps.put("Java",100);//覆盖前面的值
        maps.put(null,null); //Map集合的键值对可以为null
        System.out.println(maps);

        //清空
        //maps.clear();
        //System.out.println(maps);

        //3.判断集合是否为空
        System.out.println(maps.isEmpty());

        //4.根据键值获取对应值
        Integer key = maps.get("枸杞");
        System.out.println(maps.get("Java"));
        System.out.println(maps.get("hello"));//null,没有就返回null

        //5.根据键值删除整个元素（删除键值返回删除的值）
        System.out.println(maps.remove("鸿星尔克"));
        System.out.println(maps);

        //6.判断是否包含某个键？
        System.out.println(maps.containsKey("hello"));
        System.out.println(maps.containsKey("Java"));

        //7.是否包含某个值
        System.out.println(maps.containsValue(10000));
        System.out.println(maps.containsValue(100));

        //8.返回所有键的集合
        Set<String> strings = maps.keySet();//返回的是Set集合
        System.out.println(strings);

        //9.获取所有值的集合
        Collection<Integer> values=maps.values();
        System.out.println(values);

        //获取集合的大小
        System.out.println(maps.size());

        //合并其他Map集合
        Map<String,Integer> map1=new HashMap<>();
        map1.put("Java1",1);
        map1.put("Java2",2);
        Map<String,Integer> map2=new HashMap<>();
        map2.put("Java3",3);
        map2.put("Java4",4);
        map1.putAll(map2);//把集合map2中的元素拷贝一份到map1中
        System.out.println(map1);
        System.out.println(map2);
```

## Map集合的遍历

### 键找值

### 键值对

* 先获取Map集合的全部键的Set集合。

* 遍历键的Set集合，然后通过键提取对应值。

```java
        //1.键找值，先拿到集合所有键值
        Set<String> keys=maps.keySet();
        //2.遍历每个键，根据键提取值
        for (String key : keys) {
            System.out.println(maps.get(key));
        }

        //键值对
        //通过调用entrySet把map转化为Set集合类型
        //集合中的类型为Map.entry<String,Integer>
        //1.把Map集合转化为Set集合
        Set<Map.Entry<String,Integer>> entries=maps.entrySet();
        //2.开始遍历
        for (Map.Entry<String, Integer> entry : entries) {
            System.out.println(entry.getKey());
            System.out.println(entry.getValue());
        }


```

### Map集合的遍历方式三：Lambda

| default void forEach(BiConsumer<?  super  K,  ? super  V>  action) | 结合lambda遍历Map集合 |
| ------------------------------------------------------------ | --------------------- |

```java
        //3.Lambda表达式遍历
        maps.forEach(new BiConsumer<String, Integer>() {
            @Override
            public void accept(String s, Integer integer) {
                System.out.println(s+"--->"+integer);
            }
        });
        //简化
        maps.forEach((s,integer)-> System.out.println(s+"--->"+integer));

```

# HashMap

* 由键决定：无序、不重复、无索引。HashMap底层是哈希表结构的。
* 依赖hashCode方法和equals方法保证键的唯一。
* 如果键要存储的是自定义对象，需要重写hashCode和equals方法。
* 基于哈希表。增删改查的性能都较好。

# LinkedHashMap

# TreeMap

* HashMap是Map里面的一个实现类。特点都是由键决定的：无序、不重复、无索引

* 没有额外需要学习的特有方法，直接使用Map里面的方法就可以了。

* HashMap跟HashSet底层原理是一模一样的，都是哈希表结构，只是HashMap的每个元素包含两个值而已。

**实际上：Set系列集合的底层就是Map实现的，只是Set集合中的元素只要键数据，不要值数据而已。**



# 集合嵌套

```java
package Map_demo;

import java.util.*;
import java.util.function.BiConsumer;

public class demo1 {
    public static void main(String[] args) {
        //记录每个学生的选择情况
        //使用Map集合存储
        Map<String,List<String>> data=new HashMap<>();

        //2.把学生的选择存进去
        List<String> selects=new ArrayList<>();
        Collections.addAll(selects,"A","B");
        data.put("橙留香",selects);

        List<String> selects1=new ArrayList<>();
        Collections.addAll(selects1,"A","C");
        data.put("陆小果",selects1);

        List<String> selects2=new ArrayList<>();
        Collections.addAll(selects2,"A","B","C","D");
        data.put("菠萝吹雪",selects);

        System.out.println(data);

        //3.统计每个景点的选择人数
        Map<String,Integer> infos=new HashMap<>();
        //4.提取每个人选择的景点
        Collection<List<String>> values=data.values();

        for (List<String> value : values) {
            for (String s : value) {
                if(infos.containsKey(s)){
                    infos.put(s,infos.get(s)+1);
                }else {
                    infos.put(s,1);
                }
            }
        }
        System.out.println(infos);
    }
}

```

# 不可变集合

* 不可变集合，就是不可被修改的集合。

* 集合的数据项在创建的时候提供，并且在整个生命周期中都不可改变。否则报错。

| 方法名称                                  | 说明                               |
| ----------------------------------------- | ---------------------------------- |
| static  <E> List<E> of(E…elements)        | 创建一个具有指定元素的List集合对象 |
| static  <E> Set<E> of(E…elements)         | 创建一个具有指定元素的Set集合对象  |
| static <K  , V>  Map<K，V> of(E…elements) | 创建一个具有指定元素的Map集合对象  |

**这个集合不能添加，不能删除，不能修改。**

```java
        List<Double> lists = List.of(10.0);
        //lists.add(689.0);//报错

        Set<String> names = Set.of("橙留香", "陆小果");
        //names.add("菠萝吹雪");
        System.out.println(names);

        Map<String,Integer> maps=Map.of("橙留香",1,"陆小果",2);
        //maps.put("菠萝吹雪",3);
        System.out.println(maps);
```

# Stream流

**目的：用于简化集合和数组操作的API。**

```java
        //初步体验Stream流
        List<String> names = new ArrayList<>();
        Collections.addAll(names,"张三","张无极","李四");
        //1.从集合找出张姓人
        List<String> zhangList=new ArrayList<>();
        names.forEach(s-> {
                if(s.charAt(0)=='张')
                    zhangList.add(s);
        });
        System.out.println(zhangList);

        //3.使用Stream流
        names.stream().filter(s->s.startsWith("张")).forEach(s-> System.out.println(s));
        //再加上判断长度为3，可以继续链式编程
        names.stream().filter(s->s.startsWith("张")).filter(s->s.length()==3);
        //names.stream().filter(s->s.startsWith("张")&&s.length()==3);

```

## 核心思想(流水线)

* 先得到集合或者数组的Stream流（就是一根传送带）
* 把元素放上去
* **然后就用这个Stream流简化的API来方便的操作元素。**

传进filter函数接口的是一个匿名内部类，filter函数里边的形参本就是一个函数接口new出来的对象，刚好可以使用lambda表达式。

<img src="C:\Users\痞妖\AppData\Roaming\Typora\typora-user-images\image-20230531215727830.png" alt="image-20230531215727830" style="zoom:50%;" />

**支持链式编程**

## Stream流的三类方法

* **获取Stream流**
  创建一条流水线，并把数据放到流水线上准备进行操作
* **中间方法**
  流水线上的操作。一次操作完毕之后，还可以继续进行其他操作。（**链式编程）注意链式编程说的是中间方法**
* **终结方法**
  一个Stream流只能有一个终结方法，是流水线上的最后一个操作

### 集合获取Stream流的方式

| default  Stream<E> stream() | 获取当前集合对象的Stream流 |
| --------------------------- | -------------------------- |

### 数组获取Stream流的方式

| public  static <T>  Stream<T>  stream(T[]  array) | 获取当前数组的Stream流          |
| ------------------------------------------------- | ------------------------------- |
| public  static<T>  Stream<T>  of(T...  values)    | 获取当前数组/可变数据的Stream流 |

```java
        //Collection集合获取流
        Collection<String> list=new ArrayList<>();
        Stream<String> stream = list.stream();
        //Map集合获取Stream流对象
        Map<String,Integer> maps=new HashMap<>();
        //maps.stream();//报错，Map是没有这个函数的，可以键和值分开拿Stream流
        //键流
        Stream<String> keyStream=maps.keySet().stream();
        //值流
        Stream<Integer> valueStream=maps.values().stream();
        //键值对流
        Stream<Map.Entry<String,Integer>> keyValueStream=maps.entrySet().stream();

        //数组获取流
        String[] s = {};
        Stream<String> stream1 = Arrays.stream(s);//Arrays里边的静态方法
        Stream<String> stream2 = Stream.of(s);//Stream里边的静态方法
        
```

### 中间方法：常用API

**在Stream流中无法直接修改数组或集合中的数据**

| 名称                                                 | 说明                                           |
| ---------------------------------------------------- | ---------------------------------------------- |
| Stream<T>  filter(Predicate<?  super  T>  predicate) | 用于对流中的数据进行**过滤。**                 |
| Stream<T>  limit(long maxSize)                       | 获取前几个元素                                 |
| Stream<T>  skip(long n)                              | 跳过前几个元素                                 |
| Stream<T>  distinct()                                | 去除流中重复的元素。依赖(hashCode和equals方法) |
| static  <T> Stream<T> concat(Stream  a, Stream b)    | **合并**a和b两个流为一个流                     |

### 终结方法(不返回流）

| 名称                           | 说明                         |
| ------------------------------ | ---------------------------- |
| void  forEach(Consumer action) | 对此流的每个元素执行遍历操作 |
| long count()                   | 返回此流中的元素数           |

### 自行搜索方法引用，构造器引用p141

就是lambda的超级简化

```java
package demo2;

import java.util.*;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.stream.Stream;

public class Test {
    public static void main(String[] args) {
        List<String> list=new ArrayList<>();
        list.add("张无忌");
        list.add("周芷若");
        list.add("赵敏");
        list.add("张强");
        list.add("张三丰");
        list.add("张三丰");
        //filter方法对流中数据进行过滤
        list.stream().filter(new Predicate<String>() {
            @Override
            public boolean test(String s) {
                return s.startsWith("张");
            }
        });//filter会遍历集合的每个数据,每遍历一个元素，就调用
        //简化版本+链式编程  foreach不是中间方法所以就终结了流水线
        list.stream().filter(s->s.startsWith("张")).forEach(System.out::println);
        list.stream().filter(s->s.startsWith("张")).count();

        //获取前几个元素
        list.stream().filter(s->s.startsWith("张")).limit(2).forEach(System.out::println);

        //跳过前几个元素
        list.stream().filter(s->s.startsWith("张")).skip(2).forEach(System.out::println);

        //去除流中的重复元素
        list.stream().filter(s->s.startsWith("张")).distinct().forEach(System.out::println);

        //Map加工方法,第一个参数原材料类型 -> 第二个参数加工后的结果的类型
        list.stream().map(new Function<String, String>() {
            @Override
            public String apply(String s) {
                return "原神的"+s;
            }
        }).forEach(s-> System.out.println(s));
        //简化
        //list.stream().map(s->"原神的"+s);

        //合并两个流
        Stream<String> s1=list.stream().filter(s->s.startsWith("张"));
        Stream<String> s2=Stream.of("Java","cpp");
        //函数原型：public static <T> Stream<T> concat(Stream<? extends T> a, Stream<? extends T> b)
        Stream<String> s3=Stream.concat(s1,s2);
        //其实只要合并的两个流都是T的子类，就可以合并，比如一个String，一个Integer，合并出Object
        s3.forEach(System.out::println);

    }
}

```

### 收集Stream流

**就是把Stream流操作后的结果数据转回到集合或者数组中去。**

| R collect(Collector collector) | 开始收集Stream流，指定收集器 |
| ------------------------------ | ---------------------------- |



**Collectors工具类提供了具体的收集方式**

| public static <T> Collector toList()                         | 把元素收集到List集合中 |
| ------------------------------------------------------------ | ---------------------- |
| public static <T> Collector toSet()                          | 把元素收集到Set集合中  |
| public static Collector toMap(Function keyMapper  , Function valueMapper) | 把元素收集到Map集合中  |

```java
package demo3;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Set;
import java.util.function.IntFunction;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class Test {
    public static void main(String[] args) {
        List<String> list=new ArrayList<>();
        list.add("张无忌");
        list.add("周芷若");
        list.add("赵敏");
        list.add("张强");
        list.add("张三丰");
        list.add("张三丰");
        Stream<String> s1=list.stream().filter(s->s.startsWith("张"));
        List<String> s2=s1.collect(Collectors.toList());
        System.out.println(s2);

        //直接将s1流转化为Set会报错，因为流只能使用一次，上边已经转化为了List集合
        //想用就要创建新的流
        Stream<String> t=list.stream().filter(s->s.startsWith("张"));
        Set<String> s3=t.collect(Collectors.toSet());
        System.out.println(s3);
        Stream<String> x= list.stream();
        x.filter(s->s.startsWith("张"));
        //x.filter(s->s.length()==3);//同样报错，因为上面使用

        //流对象转化为数组
        Stream<String> t2=list.stream().filter(s->s.startsWith("张"));
        Object[] arr= t2.toArray();//返回的是Object类型
        System.out.println(Arrays.toString(arr));
        //这里因为流对象中可以插入其他类型的元素，所以只能转化为Object
        //这里想直接转化为String数组也可以
        Stream<String> t3=list.stream().filter(s->s.startsWith("张"));
//        String[] arrs=t3.toArray(new IntFunction<String[]>() {
//            @Override
//            public String[] apply(int value) {
//                return new String[value];
//            }
//        });
        //简化
        String[] aee=t3.toArray(String[]::new);

        //java新API
        Stream<String> t4=list.stream().filter(s->s.startsWith("张"));
        List<String> lists=t4.toList();//不可变集合
        //lists.add("java");//报错
    }
}

```

# 异常

* **异常是程序在“编译”或者“执行”的过程中可能出现的问题，注意：==语法错误不算在异常体系中。==** 

* 比如:数组索引越界、空指针异常、 日期格式化异常，等…

* 异常的重要性：异常一旦出现了，如果没有提前处理，程序就会退出JVM虚拟机而终止，研究异常并且避免异常，然后提前处理异常，**体现的是程序的安全, 健壮性。**

<img src="C:\Users\痞妖\AppData\Roaming\Typora\typora-user-images\image-20230603103915527.png" alt="image-20230603103915527" style="zoom: 67%;" />

<img src="C:\Users\痞妖\AppData\Roaming\Typora\typora-user-images\image-20230603104152132.png" alt="image-20230603104152132" style="zoom:50%;" />

## 常见运行时异常

```java
        //1.数组越界异常：ArarryIndexOutOfBoundsException
        int[] a={1,2};
        System.out.println(a[2]);

        //2.空指针异常NullPointerException，输出是没有问题的，但是调用功能就错了
        String name=null;
        System.out.println(name);
        name.length();

        //3.类型转换异常：ClassCastException
        Object o=23;
        String s= (String) o;

        //4.数学操作异常
        System.out.println(10/0);

        //5.数字转化异常
        String num="26aa";
        Integer it= Integer.valueOf(num);
```



**运行时异常：一般是程序员业务没有考虑好或者是编程逻辑不严谨引起的程序错误，自己的水平有问题！**

## 常见编译时异常

```java
    public static void main(String[] args) throws ParseException {
        String date="2023-6-3 11:06:33";
        //创建一个简单日期格式
        SimpleDateFormat sdf=new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        Date d=sdf.parse(date);//写代码时会提醒一次，然后抛出错误就可以
        //但是就算抛出了错误，如果最后写错了还是会报错
        SimpleDateFormat sdf2=new SimpleDateFormat("yyyy/MM-dd HH:mm:ss");
        Date d2=sdf2.parse(date);
    }
```

**编译时异常的作用是什么：**

* 是担心程序员的技术不行，在编译阶段就爆出一个错误, 目的在于提醒不要出错!
* 编译时异常是可遇不可求。遇到了就遇到了呗。

**编译时异常的特点**

* 编译时异常：继承自Exception**的异常或者其子类**
* **编译阶段报错**，必须处理，否则代码不通过。

## 异常的默认处理机制

* 默认会在出现异常的代码那里自动的创建一个异常对象：ArithmeticException。（÷0的异常）
* 异常会从方法中出现的点这里抛出给调用者，调用者最终抛出给JVM虚拟机。
* 虚拟机接收到异常对象后，先在控制台直接输出异常栈信息数据。
* 直接从当前执行的异常点干掉当前程序。
* 后续代码没有机会执行了，因为程序已经死亡。

<img src="C:\Users\痞妖\AppData\Roaming\Typora\typora-user-images\image-20230603114617641.png" alt="image-20230603114617641" style="zoom:50%;" />



## 编译时异常的处理机制

**处理方式有三种**

* 出现异常直接抛出去给调用者，调用者也继续抛出去。

* 出现异常自己捕获处理，不麻烦别人。
* 前两者结合，出现异常直接抛出去给调用者，调用者捕获处理。

### 1.throws

throws：**用在方法上**，可以**将方法内部出现的异常抛出去给本方法的调用者处理**。**这种方式并不好**，发生异常的方法自己不处理异常，如果异常最终抛出去给虚拟机将引起程序死亡。

**抛出异常格式：**这种方式可以写抛出去很多个异常，但是真正抛出去的就只有一个，因为遇到出现异常的情况，就会直接抛出，然后程序就会终止，不会接着运行

>方法 throws 异常1 ，异常2 ，异常3 ..{
> }

**规范做法**:可以抛出一切异常

>方法 throws Exception{
> }

### 2.try...catch...

```java
package ExceptionDemo;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.InputStream;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

public class demo3 {
    public static void main(String[] args) {
        System.out.println("程序开始。。。");
        parseTime2("2021-10-1 12:8:30");
        System.out.println("程序结束。。。");
    }

    public static void parseTime(String date) {
        //Ctrl + Alt + T 选择包围方式
        try {
            SimpleDateFormat sdf=new SimpleDateFormat("yyyy-MM-dd日HH:mm:ss");
            Date d=sdf.parse(date);
            System.out.println(d);
        } catch (ParseException e) {
            System.out.println("出现了解析时间异常~~~~~");
        }
        try {
            InputStream is=new FileInputStream("E:/hello.jpg");
        } catch (FileNotFoundException e) {
            System.out.println("没有这个东西，~~~~~");
        }
    }
    //写法二
    public static void parseTime2(String date) {
        try {
            SimpleDateFormat sdf=new SimpleDateFormat("yyyy-MM-dd日HH:mm:ss");
            Date d=sdf.parse(date);
            System.out.println(d);
            InputStream is=new FileInputStream("E:/hello.jpg");
        } catch (ParseException e) {
            throw new RuntimeException(e);
        } catch (FileNotFoundException e) {
            throw new RuntimeException(e);
        }
    }
    //企业级写法，用Exception
    public static void parseTime3(String date) {
        try {
            SimpleDateFormat sdf=new SimpleDateFormat("yyyy-MM-dd日HH:mm:ss");
            Date d=sdf.parse(date);
            System.out.println(d);
            InputStream is=new FileInputStream("E:/hello.jpg");
        } catch (Exception e) {
            //e.printStackTrace();
            throw new RuntimeException(e);
        }
    }
}

```

### 3.前两者结合

[【java知识点异常】throw new RuntimeException(e)与e.printStackTrace( )的区别](https://blog.csdn.net/xuzhuaaron1/article/details/73611404)

```java
package ExceptionDemo;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.InputStream;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

public class demo4 {
    public static void main(String[] args) {
        System.out.println("程序开始。。。");
        try {
            parseTime("2021-10-1 12:8:30");
            System.out.println("功能操作成功");
        } catch (Exception e) {
            System.out.println("功能操作失败");
            throw new RuntimeException(e);
        }
        System.out.println("程序结束。。。");
    }

    public static void parseTime(String date) throws Exception {
        //Ctrl + Alt + T 选择包围方式
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd/HH:mm:ss");
        Date d = sdf.parse(date);
        System.out.println(d);
        System.out.println("出现了解析时间异常~~~~~");
        InputStream is = new FileInputStream("E:/hello.jpg");
    }
}
```

* **在开发中按照规范来说第三种方式是最好的：底层的异常抛出去给最外层，最外层集中捕获处理。**

* **实际应用中，只要代码能够编译通过，并且功能能完成，那么每一种异常处理方式似乎也都是可以的。**

## 运行时异常的处理机制

运行时异常编译阶段不会出错，是运行时才可能出错的，所以编译阶段不处理也可以

按照规范建议还是处理：**建议在最外层调用处集中捕获处理即可**。

<img src="C:\Users\痞妖\AppData\Roaming\Typora\typora-user-images\image-20230603202437862.png" alt="image-20230603202437862" style="zoom:50%;" />

## 异常的例子

```java
package ExceptionDemo;

import java.util.Scanner;

public class demo5 {
    public static void main(String[] args) {
        //需求：输入价格，直到合法为止，要求价格大于0
        Scanner sc = new Scanner(System.in);
        while(true){
            //转化为Double类型的数据
            System.out.println("请输入价格");
            //为什么要用字符串接收价格，因为如果输入的是不合法的数据例如abc，那么直接用Double接收就直接异常终止了
            String priceStr=sc.nextLine();
            double b= 0;
            try {
                b = Double.parseDouble(priceStr);
            } catch (Exception e) {
                continue;
            }
            //判断价格是否合法
            if (b>0){
                System.out.println("正确的:"+b);
                break;
            }else{
                System.out.println("价格不合法~~");
            }
        }
    }
}

```

## 自定义异常

### 自定义编译时异常

* 定义一个类继承Exception
* 重写构造区
* 在出现异常的地方用throw new 自定义对象抛出

**作用：编译时异常是编译阶段就报错，提醒更加强烈，一定需要处理！！**(无论到底有没有错误，都会提示报错，这样才能起到提醒作用)

```java
package ExceptionDemo;

public class SduException extends Exception {
    public SduException() {
    }

    public SduException(String message) {
        super(message);
    }
}
```

 ```java
 package ExceptionDemo;
 
 public class demo6 {
     public static void main(String[] args) {
         try {
             checkAge(-4);//编译时异常如果不在方法旁边抛出或者用try catch包围就会报错，起到提醒作用
         } catch (SduException e) {
             throw new RuntimeException(e);
         }
     }
 
     public static void checkAge(int age) throws SduException {
         if(age<0||age>200){
             //抛出异常给调用者
             //throw:在方法内部直接创建一个异常对象，并抛出
             //throws:用在方法申明上，抛出方法内部异常
             throw new SduException("年龄不正常");
         }
     }
 }
 ```

### 自定义运行时异常

* 定义一个异常类继承RuntimeException.

* 重写构造器。

* 在出现异常的地方用throw new 自定义对象抛出!

```java
package ExceptionDemo;

public class SduException extends RuntimeException {
    public SduException() {
    }
    public SduException(String message) {
        super(message);
    }
}
```

```java
package ExceptionDemo;

public class demo6 {
    public static void main(String[] args) {
        try {
            checkAge(-4);//编译阶段不会报错
        } catch (SduException e) {
            throw new RuntimeException(e);
        }
    }

    public static void checkAge(int age) throws SduException {
        if(age<0||age>200){
            //抛出异常给调用者
            throw new SduException("年龄不正常");
        }
    }
}
```

# 日志

* 可以将系统执行的信息选择性的记录到指定的位置（控制台、文件中、数据库中）。

* **可以随时以开关的形式控制是否记录日志，无需修改源代码。**

|          | **输出语句**               | **日志技术**                         |
| -------- | -------------------------- | ------------------------------------ |
| 输出位置 | 只能是控制台               | 可以将日志信息写入到文件或者数据库中 |
| 取消日志 | 需要修改代码，灵活性比较差 | **不需要修改代码，灵活性比较好**     |
| 多线程   | **性能较差**               | **性能较好**                         |

<img src="C:\Users\痞妖\AppData\Roaming\Typora\typora-user-images\image-20230604101501477.png" alt="image-20230604101501477" style="zoom:60%;" />

* 日志规范接口是不能直接用的，因为是接口，不能创建对象，真正用的是日志实现框架
* Logback是重点，实现的是slf4j接口

## Logback

**Logback是基于slf4j的日志规范实现的框架。**

**Logback主要分为三个技术模块：**

* logback-core： logback-core 模块**为其他两个模块奠定了基础**，必须有。
* logback-classic：它**是log4j的一个改良版本**，同时它完整实现了slf4j API。
* logback-access 模块与 Tomcat 和 Jetty 等 Servlet 容器集成，以提供 HTTP 访问日志功能

**使用Logback需要使用哪几个模块，各自的作用是什么**

1. slf4j-api：日志规范
2. logback-core：基础模块。
3. logback-classic：它是log4j的一个改良版本，同时它完整实现了slf4j API



①：在项目下新建文件夹lib，导入Logback的相关jar包到该文件夹下，并添加到项目库中去。
②：必须将Logback的核心配置文件logback.xml直接拷贝到src目录下。
③：在代码中获取日志的对象
④：使用日志对象输出日志信息

```java
package demo1;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

//快速搭建Logback日志框架 记录程序的执行情况到控制台 到文件中
public class Test1 {
    public static final Logger LOGGER = LoggerFactory.getLogger("Test1.class");

    public static void main(String[] args) {
        try {
            LOGGER.debug("main方法开始执行了~~~");
            LOGGER.info("我开始记录第二行日志，我要做除法~~~");
            int a = 10;
            int b = 0;
            LOGGER.trace("a=" + a);
            LOGGER.trace("b="+b);
            System.out.println(a/b);
        } catch (Exception e) {
             e.printStackTrace();
             LOGGER.error("功能出现异常"+e);
        }
    }
}
```

## Logback配置详解

[.xml的配置](https://www.jianshu.com/p/75f9d11ae011)

**日志级别设置**

* 级别程度依次是：**TRACE< DEBUG< INFO<WARN<ERROR ; 默认级别是debug**（忽略大小写），对应其方法。

* 作用：用于控制系统中哪些日志级别是可以输出的，只输出级别大于等于设定级别的日志信息。

* ALL  和 OFF分别是打开全部日志信息，及关闭全部日志信息。

```xml
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
    <!--
        CONSOLE ：表示当前的日志信息是可以输出到控制台的。
    -->
    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <!--输出流对象 默认 System.out 改为 System.err-->
        <target>System.out</target>
        <encoder>
            <!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度
                %msg：日志消息，%n是换行符-->
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%-5level]  %c [%thread] : %msg%n</pattern>
        </encoder>
    </appender>

    <!-- File是输出的方向通向文件的 -->
    <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
            <charset>utf-8</charset>
        </encoder>
        <!--日志输出路径-->
        <file>C:/code/siyee-data.log</file>
        <!--指定日志文件拆分和压缩规则-->
        <rollingPolicy
                class="ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy">
            <!--通过指定压缩文件名称，来确定分割文件方式-->
            <fileNamePattern>C:/code/siyee-data2-%d{yyyy-MM-dd}.log%i.gz</fileNamePattern>
            <!--文件拆分大小-->
            <maxFileSize>1MB</maxFileSize>
        </rollingPolicy>
    </appender>

    <!--

    level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR,   ALL 和 OFF
   ， 默认debug
    <root>可以包含零个或多个<appender-ref>元素，标识这个输出位置将会被本日志级别控制。
    -->
    <root level="Error">
        <!--注意：如果这里不配置关联打印位置，该位置将不会打印日志 -->
        <!-- 将文件删除之后，依旧会创建 .log文件，但是里边不会记录东西 -->
        <appender-ref ref="CONSOLE"/>
        <appender-ref ref="FILE" />
    </root>
</configuration>
```

# File

**File类创建对象：**

| 方法名称                                      | 说明                                               |
| --------------------------------------------- | -------------------------------------------------- |
| **public**  File(String pathname)             | 根据文件路径创建文件对象                           |
| **public** File(String  parent, String child) | 根据父路径名字符串和子路径名字符串创建文件对象     |
| **public** File(File parent, String child)    | 根据父路径对应文件对象和子路径名字符串创建文件对象 |

```java
        //学会创建File对象
        //路径写法：C:/Users/痞妖/Desktop
        //C:\\Users\\痞妖\\Desktop
        //File.separator
        File f=new File("C:\\Users\\痞妖\\Desktop\\shiyou\\石油调度\\input\\input1.in");
        File f2=new File("C:"+File.separator+"Users"+File.separator+"\\痞妖\\Desktop\\shiyou\\石油调度\\input\\input1.in");
        System.out.println(f.length());
        System.out.println(f.exists());
        //2.File支持相对路径和绝对路径
        //和c++不一样这里的相对路径是相对于工程来说的

        //3.File对象，可以是文件夹和文件
        File f3=new File("C:\\Users\\痞妖\\Desktop\\大二下\\Java\\2、基础加强课全套PPT");
        System.out.println(f3.length());//直接调用length方法是没有意义的，因为文件夹是没有大小的，在资源管理器中可以看到是操作系统做的操作
        System.out.println(f3.exists());
```

# File常用API

## 获取文件信息

| 方法名称                         | 说明                                 |
| -------------------------------- | ------------------------------------ |
| public  boolean isDirectory()    | 判断此路径名表示的File是否为文件夹   |
| public  boolean isFile()         | 判断此路径名表示的File是否为文件     |
| public  boolean  exists()        | 判断此路径名表示的File是否存在       |
| public long  length()            | 返回文件的大小（字节数量）           |
| public  String getAbsolutePath() | 返回文件的绝对路径                   |
| public  String getPath()         | 返回定义文件时使用的路径             |
| public  String getName()         | 返回文件的名称，带后缀               |
| public  long lastModified()      | 返回文件的最后修改时间（时间毫秒值） |

## 创建/删除文件

| 方法名称                       | 说明                 |
| ------------------------------ | -------------------- |
| public boolean createNewFile() | 创建一个新的空的文件 |
| public boolean mkdir()         | 只能创建一级文件夹   |
| public boolean mkdirs()        | 可以创建多级文件夹   |

| 方法名称                 | 说明                                   |
| ------------------------ | -------------------------------------- |
| public  boolean delete() | 删除由此抽象路径名表示的文件或空文件夹 |

**delete方法默认只能删除文件和空文件夹，delete方法直接删除不走回收站**

<img src="C:\Users\痞妖\AppData\Roaming\Typora\typora-user-images\image-20230610153533043.png" alt="image-20230610153533043" style="zoom:50%;" />

```java
        //File f=new File("FILE/test/abc");
        //创建新文件，返回成功与否，只能创建文件
        //System.out.println(f.createNewFile());

        //创建一级目录
        File f2=new File("FILE/test");
        f2.mkdir();

        //创建多级目录
        //File f3=new File("FILE/test/aaa/bbb");
        //f3.mkdirs();

        //删除空文件夹，或文件        
        File f4=new File("FILE/test");
        System.out.println(f4.delete());
```

## 遍历字符串

| 方法名称                        | 说明                                                         |
| ------------------------------- | ------------------------------------------------------------ |
| public String[] list()          | 获取当前目录下所有的"一级文件名称"到一个字符串数组中去返回。 |
| public File[] listFiles()(常用) | 获取当前目录下所有的"一级文件对象"到一个文件对象数组中去返回（重点） |

1. 当文件不存在时或者代表文件时，返回null
2. 当文件对象代表一个空文件夹时，返回一个长度为0的数组
3. 当文件对象是一个有内容的文件夹时，将里面所有文件和文件夹的路径放在File数组中返回
4. 当文件对象是一个有隐藏文件的文件夹时，将里面所有文件和文件夹的路径放在File数组中返回，包含隐藏文件
5. 当没有权限访问该文件夹时，返回null

```java
        //1.定位一个目录
        File f1=new File(".");
        System.out.println(f1.getAbsolutePath());
        String[] names=f1.list();
        for (String name : names) {
            System.out.println(name);
        }

        //2.一级文件目录
        //获取当前目录下所有的一级文件对象到一个文件数组中
        File[] files=f1.listFiles();
        for (File file : files) {
            System.out.println(file.getAbsolutePath());
        }
```

# 递归

​	递归的方向必须走向递归终结点。

## 文件搜索

```java
package Test;

import java.io.File;
import java.io.IOException;

public class demo1 {
    public static void main(String[] args) throws IOException {
        //在D盘找到 Steam++.exe 这个文件，并返回绝对路径
        searchFile(new File("D:/"),"Steam++.exe");
        File f=new File("D:/aaa");

    }
    public static void searchFile(File dir,String fileName){
        //判断是否是目录
        if(dir!=null&&dir.isDirectory()){
            File[] files= dir.listFiles();
            if(files!=null&&files.length>0){
                for (File file : files) {
                    if(file.isDirectory()){
                        searchFile(file,fileName);
                    }else{
                        if(file.getName().equals(fileName)){
                            System.out.println("found out"+file.getAbsolutePath());
                            //启动它
                            Runtime r=Runtime.getRuntime();
                            try {
                                r.exec(file.getAbsolutePath());
                            } catch (IOException e) {
                                throw new RuntimeException(e);
                            }
                        }
                    }
                }
            }
        }
    }
}

```

# 字符集

**字符集（Character Set）是多个字符的集合，字符集种类较多，每个字符集包含的字符个数不同，常见字符集有：**  

* ASCII字符集
* GBK字符集
* Unicode（UTF-8）字符集等。

要注意每个字符集里边的都兼容ASCII字符集，而且都是一个字节表示，而中文在GBK是两个字节，UTF-8中是三个。所以一个字符集里边不同的字符所占字节数不同

**常见字符集底层字符的编码是什么样的？**
英文和数字等在任何国家的字符集中都占1个字节
GBK字符中一个中文字符占2个字节
UTF-8编码中一个中文1般占3个字节
**编码前的字符集和解码时的字符集有什么要求？**
必须一致，否则会出现字符乱码
英文和数字不会乱码

## 字符集的编码解码操作

**String编码**

| 方法名称                            | 说明                                                         |
| ----------------------------------- | ------------------------------------------------------------ |
| byte[] getBytes()                   | 使用平台的默认字符集将该  String编码为一系列字节，将结果存储到新的字节数组中 |
| byte[] getBytes(String charsetName) | 使用指定的字符集将该 String编码为一系列字节，将结果存储到新的字节数组中 |

**String解码**

| 构造器                                   | 说明                                                         |
| ---------------------------------------- | ------------------------------------------------------------ |
| String(byte[] bytes)                     | 通过使用平台的默认字符集解码指定的字节数组来构造新的  String |
| String(byte[] bytes, String charsetName) | 通过指定的字符集解码指定的字节数组来构造新的 String          |

```java
		//1.编码：把文字转换成字节
        String name = "原神启动Genshin impact";
        byte[] bytes=name.getBytes();//以当前默认字符集进行编码（UTF-8）
        System.out.println(bytes.length);
        System.out.println(Arrays.toString(bytes));
        byte[] bytes2=name.getBytes("GBK");//指定编码格式
        System.out.println(bytes2.length);

        //2.解码：把字节转化为对应的中文格式（编码解码的字符集必须一致，否则会有乱码）
        String rs=new String(bytes);
        System.out.println(rs);
        String rs2=new String(bytes2);
        System.out.println(rs2);//乱码
        String rs3=new String(bytes2,"GBK");
        System.out.println(rs3);
```

# IO流

也称为输入输出流	用来读写数据

* I 表示intput，**把硬盘文件中的数据读入到内存的过程**，称之输入，负责读。

* O 表示output，**把内存中的数据写出到硬盘文件的过程**，称之输出，负责写。

<img src="C:\Users\痞妖\AppData\Roaming\Typora\typora-user-images\image-20230611003723615.png" alt="image-20230611003723615" style="zoom:67%;" />

<img src="C:\Users\痞妖\AppData\Roaming\Typora\typora-user-images\image-20230611003944331.png" alt="image-20230611003944331" style="zoom:50%;" />

## 流的四大类

* 字节输入流：以内存为基准，来自磁盘文件/网络中的数据以字节的形式读入到内存中去的流称为字节输入流。

* 字节输出流：以内存为基准，把内存中的数据以字节写出到磁盘文件或者网络中去的流称为字节输出流。

* 字符输入流：以内存为基准，来自磁盘文件/网络中的数据以字符的形式读入到内存中去的流称为字符输入流。

* 字符输出流：以内存为基准，把内存中的数据以字符写出到磁盘文件或者网络介质中去的流称为字符输出流。

![image-20230611004342863](C:\Users\痞妖\AppData\Roaming\Typora\typora-user-images\image-20230611004342863.png)

## 字节流

### 文件字节输入流FileInputStream

```java
        //1.创建一个文件字节输入流管道与源文件接通
        InputStream is=new FileInputStream("FILE/src/test.txt");
        //2.读取一个字节返回
        int b=is.read();
        System.out.println(b+"   "+(char)b);
        //读取完毕会返回-1

        //3.使用循环改进
        //缺点很明显只能读一个字节，如果读到中文，就读不出来了
        int b1;
        while((b1=is.read())!=-1){
            System.out.println((char)b1);
        }
```

```java
        //读取数据为：123原神ab启动
        //创建文件输入流管道
        InputStream is=new FileInputStream("FILE/src/test.txt");
        //定义一个字节数组，用于读取字节数组
        byte[] buffer = new byte[3];
        int len=is.read(buffer);
        System.out.println(len);
        String rs=new String(buffer);
        System.out.println(rs);

        int len2=is.read(buffer);
        System.out.println(len2);
        String rs2=new String(buffer);
        System.out.println(rs2);

        int len3=is.read(buffer);
        System.out.println(len3);
        String rs3=new String(buffer);
        System.out.println(rs3);

        int len4=is.read(buffer);
        System.out.println(len4);
        String rs4=new String(buffer);//此时读取数据只读了两个，而buffer第三个数据没有被刷新，所以会有一个乱码
        String rs5=new String(buffer,0,len4);// 读多少出多少
        System.out.println(rs5);

        //循环改善
        InputStream is2=new FileInputStream("FILE/src/test.txt");
        //定义一个字节数组，用于读取字节数组
        byte[] buffer2 = new byte[3];
        while((len=is2.read(buffer))!=-1){
            System.out.print(new String(buffer,0,len));
        }
/*
3
123
3
原
3
神
3
abc
启动
*/
```



**如何解决输入流读取中文内存输出乱码问题**

* 一次性读完所有字节，但是如果文件过大，会有内存溢出的风险

```java
        //读取数据为：123原神ab
        //1. 创建文件输入流管道
        File f=new File("FILE/src/test.txt");
        InputStream is=new FileInputStream(f);
        //使用文件字节输入流一次性读完文件的全部字节，可以解决乱码问题

        //2.定义一个字节数组和文件大小一致
        //这个会有潜在的风险，如果文件过大，比如10G，那么字节数组也要开辟10G，有可能会导致内存不足
        byte[] buffer = new byte[(int) f.length()];//返回的是long，需要强转
        System.out.println(is.read(buffer));
        System.out.println(new String(buffer));

        //简化版本,提供的API，但是也有内存溢出的风险
        byte[] bytes2=is.readAllBytes();
        System.out.println(new String(bytes2));
```

**总结：字节输入流不适合读入中文**

### 文件字节输出流FileOutputStream

| 构造器                                                   | 说明                                           |
| -------------------------------------------------------- | ---------------------------------------------- |
| public FileOutputStream(File file)                       | 创建字节输出流管道与源文件对象接通             |
| public FileOutputStream(File file，boolean append)       | 创建字节输出流管道与源文件对象接通，可追加数据 |
| public FileOutputStream(String filepath)                 | 创建字节输出流管道与源文件路径接通             |
| public FileOutputStream(String filepath，boolean append) | 创建字节输出流管道与源文件路径接通，可追加数据 |

```java
		//1.创建一个文件字节输出流管道与目标文件接通
        //默认先清空文件中的内容，然后将新的内容写进去，要以追加形式写入，就加一个true
        OutputStream os=new FileOutputStream("FILE/src/output.txt",true);//这个文件会自动创建

        //2.写数据出去
        //a. public void write(int a):写一个字节进去
        os.write('a');
        os.write(98);
        //os.write('原');//乱码

        //b. public void write(byte[] buffer):写一个字节数组进去
        byte[] bytes = {'a',97,98,99};
        os.write(bytes);

        //c. public void write(byte[]  buffer,int pos,int len):写一个字节数组的一部分进去
        os.write(bytes,0, 3);

        //换行
        os.write("\r\n".getBytes());

        //写数据必须刷新数据，还可以继续使用
        os.flush();
        os.close();//释放资源，包含了刷新操作

```

### 文件拷贝

```java
        //1.创建文件字节输入输出流管道与目标文件接通
        //默认先清空文件中的内容，然后将新的内容写进去，要以追加形式写入，就加一个true
        OutputStream os=new FileOutputStream("C:\\Users\\痞妖\\Desktop\\大二下\\数构课设\\LZW\\LZW\\output.bmp",true);//这个文件会自动创建
        InputStream is=new FileInputStream("C:\\Users\\痞妖\\Desktop\\大二下\\数构课设\\LZW\\LZW\\test.bmp");

        //学会使用字节流，完成文件的复制
        byte[] buffer=new byte[1024];
        int len = 0;//记录每次读取的字节数
        while((len = is.read(buffer))!=-1){
              os.write(buffer,0,len);
        }
        System.out.println("复制完成");

        //关闭流
        os.close();
        is.close();
```

**1.字节流适合做一切文件数据的拷贝吗？**

**任何文件的底层都是字节，拷贝是一字不漏的转移字节，只要前后文件格式、编码一致没有任何问题。**

### 资源释放的方式

**try-catch-finally**

**finally：放在try-catch后面的，无论是正常执行还是异常执行代码，**

**最后一定要执行，除非JVM退出( System.exit(0)  )。**

作用：一般用于进行最后的资源释放操作（专业级做法）

```java
package Test;

import java.io.*;

public class demo4 {
    public static void main(String[] args) {
        //1.创建文件字节输入输出流管道与目标文件接通
        //默认先清空文件中的内容，然后将新的内容写进去，要以追加形式写入，就加一个true
        OutputStream os = null;
        InputStream is = null;
        try {
            os = new FileOutputStream("FILE/src/test.txt", true);
            is = new FileInputStream("FILE/src/output.txt");

            //学会使用字节流，完成文件的复制
            byte[] buffer = new byte[1024];
            int len = 0;//记录每次读取的字节数
            while ((len = is.read(buffer)) != -1) {
                os.write(buffer, 0, len);
            }
            System.out.println("复制完成");

        } catch (Exception e) {
            throw new RuntimeException(e);
        } finally {//无论正常执行还是出现异常都会执行这里
            //关闭流
            try {
                if (os != null)
                    os.close();
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
            try {
                if (is != null)
                    is.close();
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }
    }
}

```

**JDK7改进方案**

```java
//JDK7做的优化
package Test;

import java.io.*;

public class demo3 {
    public static void main(String[] args)  {
        //1.创建文件字节输入输出流管道与目标文件接通
        //默认先清空文件中的内容，然后将新的内容写进去，要以追加形式写入，就加一个true
        try (//用完自动释放，自动调用对象的close方法，哪怕是出现了异常也会调用
                OutputStream os=new FileOutputStream("...",true);//这个文件会自动创建
                InputStream is=new FileInputStream("...");

                //int a=10;//只能释放资源，资源都实现了Closeable/AutoCloseable接口的类对象
            
                ){

            //学会使用字节流，完成文件的复制
            byte[] buffer=new byte[1024];
            int len = 0;//记录每次读取的字节数
            while((len = is.read(buffer))!=-1){
                  os.write(buffer,0,len);
            }
            System.out.println("复制完成");

            //关闭流
            os.close();
            is.close();
        } catch (Exception e) {
            throw new RuntimeException(e);
        }


    }
}
```

**JDK9改进方案**

```java
        //1.创建文件字节输入输出流管道与目标文件接通
        //默认先清空文件中的内容，然后将新的内容写进去，要以追加形式写入，就加一个true
        OutputStream os=new FileOutputStream("C:\\Users\\痞妖\\Desktop\\大二下\\数构课设\\LZW\\LZW\\output.bmp",true);//这个文件会自动创建
        InputStream is=new FileInputStream("C:\\Users\\痞妖\\Desktop\\大二下\\数构课设\\LZW\\LZW\\test.bmp");
        //os,is必须初始化，否则不能写在try中
        try (os;is){

            //学会使用字节流，完成文件的复制
            byte[] buffer=new byte[1024];
            int len = 0;//记录每次读取的字节数
            while((len = is.read(buffer))!=-1){
                  os.write(buffer,0,len);
            }
            System.out.println("复制完成");

            //关闭流
            os.close();
            is.close();
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
```

* JDK 7 以及 JDK 9的()中只能放置资源对象，否则报错

* 什么是资源呢？

* 资源都是实现了Closeable/AutoCloseable接口的类对象

## 字符流的使用

更适合读取中文输出

```java
        //每次读取一个字符
        //1.创建一个字符输入流管道与源文件接通
        Reader fr=new FileReader("FILE/src/test.txt");

        //2.读取一个字符返回，没有可读的字符返回-1
        int code = fr.read();
        System.out.println((char)code);

        //3.循环读取字符
        int code2;
        while((code2=fr.read())!=-1){
            System.out.print((char)code2);
        }
```

```java
		//一次读取一个字符数组
        FileReader fr= new FileReader("FILE/src/test.txt");
        char[] buffers=new char[5];
        int len;
        while((len=fr.read(buffers))!=-1){
            String rs=new String(buffers,0,len);
            System.out.print(rs);
        }
```

**输出流：**

| 方法名称                                   | 说明                 |
| ------------------------------------------ | -------------------- |
| void  write(int c)                         | 写一个字符           |
| void  write(char[] cbuf)                   | 写入一个字符数组     |
| void  write(char[] cbuf, int off, int len) | 写入字符数组的一部分 |
| void  write(String str)                    | 写一个字符串         |
| void  write(String str, int off, int len)  | 写一个字符串的一部分 |

```java
		//文件字符输出流
        Writer fw=new FileWriter("FILE/src/test.txt",true);
        fw.write('a');
        fw.write('我');
        fw.write("原神启动");//写字符串
        fw.write("星穹铁道".toCharArray());//写字符数组
        fw.write("原神启动",0,2);//写字符串 部分读取
        fw.write("\r\n");//换行
        fw.write("星穹铁道".toCharArray(),2,2);//写字符数组 部分读取
        fw.flush();
        fw.close();
```

* 字节流、字符流的使用场景总结？
  **字节流适合做一切文件数据的拷贝**（音视频，文本）
  **字节流不适合读取中文内容输出**
  **字符流适合做文本文件的操作**（读，写）

<img src="C:\Users\痞妖\AppData\Roaming\Typora\typora-user-images\image-20230613110319942.png" alt="image-20230613110319942" style="zoom:50%;" />

## 字节缓冲流

```java
package Test;

import java.io.*;

public class demo3 {
    public static void main(String[] args) throws Exception {
        //使用字节缓冲流完成数据的读写操作
        try (
                OutputStream os = new FileOutputStream("FILE/src/test.txt", true);
                InputStream is = new FileInputStream("FILE/src/output.txt");
                //把原始的字节输入流包装成高级字节缓存输入流
                InputStream bis = new BufferedInputStream(is);
                OutputStream bos= new BufferedOutputStream(os);
                ){
            //学会使用字节流，完成文件的复制
            byte[] buffer = new byte[1024];
            int len = 0;//记录每次读取的字节数
            while ((len = bis.read(buffer)) != -1) {
                bos.write(buffer, 0, len);
            }
            System.out.println("复制完成");

        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
}

```

**字节缓冲流性能优化原理：**
**字节缓冲输入流自带了8KB缓冲池，以后我们直接从缓冲池读取数据，所以性能较好。**
**字节缓冲输出流自带了8KB缓冲池，数据就直接写入到缓冲池中去，写数据性能极高了。**



**字节缓冲流的性能测试**

```java
package Test;

import java.io.*;

public class demo5 {
    private static final String SRC_FILE = "C:\\Users\\痞妖\\Desktop\\test.bmp";
    private static final String DEST_FILE = "C:\\Users\\痞妖\\Desktop\\";

    public static void main(String[] args) {
        copy1();//一个字节一个字节的复制
        copy2();//低级字节流一个一个字节数组复制
        copy3();//缓冲流一个一个字节复制
        copy4();//缓冲流和字节数组复制
        copy5();//用缓冲流和字节数组复制，但是字节数组大于8k
        /*
        9610
        14
        36
        6
        3*/
    }

    private static void copy5() {
        long startTime = System.currentTimeMillis();
        try (
                OutputStream os = new FileOutputStream(DEST_FILE + "4.bmp");
                InputStream is = new FileInputStream(SRC_FILE);
                //把原始的字节输入流包装成高级字节缓存输入流
                InputStream bis = new BufferedInputStream(is);
                OutputStream bos = new BufferedOutputStream(os);
        ) {
            //学会使用字节流，完成文件的复制
            byte[] buffer = new byte[1024 * 8];
            int len = 0;//记录每次读取的字节数
            while ((len = bis.read(buffer)) != -1) {
                bos.write(buffer, 0, len);
            }
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
        long endTime = System.currentTimeMillis();
        System.out.println(endTime - startTime);
    }

    private static void copy4() {
        long startTime = System.currentTimeMillis();
        try (
                OutputStream os = new FileOutputStream(DEST_FILE + "4.bmp");
                InputStream is = new FileInputStream(SRC_FILE);
                //把原始的字节输入流包装成高级字节缓存输入流
                InputStream bis = new BufferedInputStream(is);
                OutputStream bos = new BufferedOutputStream(os);
        ) {
            //学会使用字节流，完成文件的复制
            byte[] buffer = new byte[1024];
            int len = 0;//记录每次读取的字节数
            while ((len = bis.read(buffer)) != -1) {
                bos.write(buffer, 0, len);
            }
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
        long endTime = System.currentTimeMillis();
        System.out.println(endTime - startTime);
    }

    private static void copy3() {
        long startTime = System.currentTimeMillis();
        try (
                OutputStream os = new FileOutputStream(DEST_FILE + "3.bmp");
                InputStream is = new FileInputStream(SRC_FILE);
                //把原始的字节输入流包装成高级字节缓存输入流
                InputStream bis = new BufferedInputStream(is);
                OutputStream bos = new BufferedOutputStream(os);
        ) {
            //学会使用字节流，完成文件的复制
            int b = 0;//记录每次读取的字节数
            while ((b = bis.read()) != -1) {
                bos.write(b);
            }
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
        long endTime = System.currentTimeMillis();
        System.out.println(endTime - startTime);
    }

    private static void copy2() {
        long startTime = System.currentTimeMillis();
        try (
                OutputStream os = new FileOutputStream(DEST_FILE + "2.bmp");
                InputStream is = new FileInputStream(SRC_FILE);
        ) {
            //学会使用字节流，完成文件的复制
            byte[] buffer = new byte[1024];
            int len = 0;//记录每次读取的字节数
            while ((len = is.read(buffer)) != -1) {
                os.write(buffer, 0, len);
            }
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
        long endTime = System.currentTimeMillis();
        System.out.println(endTime - startTime);
    }

    //使用低级的字节流一个一个字节的复制
    private static void copy1() {
        long starttime = System.currentTimeMillis();
        try (
                InputStream is = new FileInputStream(SRC_FILE);
                OutputStream os = new FileOutputStream(DEST_FILE + "1.bmp");
        ) {
            int b;
            while ((b = is.read()) != -1) {
                os.write(b);
            }
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
        long endTime = System.currentTimeMillis();
        System.out.println(endTime - starttime);
    }
}

```

## 字符缓冲流

```java
        //一次读取一个字符数组
        FileReader fr= new FileReader("FILE/src/test.txt");
        BufferedReader br=new BufferedReader(fr);
        //用循环，每次读取一个字符数组
//        char[] buffer = new char[1024];
//        int len;
//        while((len=br.read(buffer))!=-1){
//            System.out.print(new String(buffer,0,len));
//        }

        //标准写法
        String line;
        while((line=br.readLine())!=null){
            System.out.println(line);
        }
```



```java
        //1.创建一个字符输出流管道与目标文件接通
        Writer fw = new FileWriter("FILE/src/output.txt");
        BufferedWriter bfw=new BufferedWriter(fw);
        bfw.write(98);
        bfw.newLine();//bfw.write("\r\n");
        bfw.write(99);
```

## 转换流

<img src="C:\Users\痞妖\AppData\Roaming\Typora\typora-user-images\image-20230614222640513.png" alt="image-20230614222640513" style="zoom:50%;" />

**字符输入转换流**

| 构造器                                                    | 说明                                                         |
| --------------------------------------------------------- | ------------------------------------------------------------ |
| public InputStreamReader(InputStream is)                  | 可以把原始的**字节流**按照代码默认编码转换成字符输入流。几乎不用，与默认的FileReader一样。 |
| public InputStreamReader(InputStream is ，String charset) | 可以把原始的**字节流**按照指定编码转换成字符输入流，这样字符流中的字符就不乱码了(重点) |

```java
		//代码UTF-8  文件GBK
        //1.提取GBK文件的原始字节流
        InputStream is=new FileInputStream("FILE/src/test.txt");
        Reader isr = new InputStreamReader(is,"GBK");
```

**字符输出转换流**

**如果需要控制写出去的字符使用的编码，怎么办？**

* 可以把字符以指定编码获取字节后再使用字节输出流写出去：
  “我爱你中国”.getBytes(编码)
* 也可以使用字符输出转换流实现。

| public OutputStreamWriter(OutputStream os)                  | 可以把原始的字节输出流按照代码默认编码转换成字符输出流。几乎不用。 |
| ----------------------------------------------------------- | ------------------------------------------------------------ |
| public OutputStreamWriter(OutputStream os，String  charset) | 可以把原始的**字节**输出流按照指定编码转换成字符输出流(重点) |

```java
		//代码UTF-8  文件GBK
        //1.提取GBK文件的原始字节流
        OutputStream is=new FileOutputStream("FILE/src/test.txt");
        Writer isr = new OutputStreamWriter(is,"GBK");
        BufferedWriter bos=new BufferedWriter(isr);
```

# 对象序列化

以内存为基准，把内存中的对象存储到磁盘文件中去（对象字节输出流）

<img src="C:\Users\痞妖\AppData\Roaming\Typora\typora-user-images\image-20230614231934232.png" alt="image-20230614231934232" style="zoom:50%;" />

```java
package Test;

import java.io.*;
import java.util.Objects;

public class demo7 {
    public static void main(String[] args) throws Exception {
        //使用对象字节输出流
        Student s=new Student("空","Genshin","123456",16);
        //对象序列化  把低级字节输出流包装成高级的对象字节输出流
        ObjectOutputStream oos=new ObjectOutputStream(new FileOutputStream("FILE/src/out.txt"));
        //调用序列化方法
        oos.writeObject(s);
        //释放资源
        oos.close();

        //重点，要想实现字节序列化，类必须实现Serializable接口
        //只是通知虚拟机用序列化的方式写入
        //如果有的变量不想让他参与序列化，就在前边加transient
        //在类中申明序列化的版本号

        //对象反序列化
        ObjectInputStream ois= new ObjectInputStream(new FileInputStream("FILE/src/out.txt"));
        //调用对象字节输入流的反序列化方法
        Student s1= (Student) ois.readObject();
        System.out.println(s1);
    }
}
class Student implements Serializable {
    //申明序列化的版本号
    //序列化的版本号和反序列化的版本号一致
    private static  final long serialVersionUID=1;
    private String name;
    private String loginName;
    //transient修饰的成员变量不参与序列化
    private transient String passWord;
    private int age;

    public Student() {
    }

    public Student(String name, String loginName, String passWord, int age) {
        this.name = name;
        this.loginName = loginName;
        this.passWord = passWord;
        this.age = age;
    }

    /**
     * 获取
     * @return name
     */
    public String getName() {
        return name;
    }

    /**
     * 设置
     * @param name
     */
    public void setName(String name) {
        this.name = name;
    }

    /**
     * 获取
     * @return loginName
     */
    public String getLoginName() {
        return loginName;
    }

    /**
     * 设置
     * @param loginName
     */
    public void setLoginName(String loginName) {
        this.loginName = loginName;
    }

    /**
     * 获取
     * @return passWord
     */
    public String getPassWord() {
        return passWord;
    }

    /**
     * 设置
     * @param passWord
     */
    public void setPassWord(String passWord) {
        this.passWord = passWord;
    }

    /**
     * 获取
     * @return age
     */
    public int getAge() {
        return age;
    }

    /**
     * 设置
     * @param age
     */
    public void setAge(int age) {
        this.age = age;
    }

    public String toString() {
        return "Student{name = " + name + ", loginName = " + loginName + ", passWord = " + passWord + ", age = " + age + "}";
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Student student = (Student) o;
        return age == student.age && Objects.equals(name, student.name) && Objects.equals(loginName, student.loginName) && Objects.equals(passWord, student.passWord);
    }

    @Override
    public int hashCode() {
        return Objects.hash(name, loginName, passWord, age);
    }
}
```

# 打印流

<img src="C:\Users\痞妖\AppData\Roaming\Typora\typora-user-images\image-20230614235442125.png" alt="image-20230614235442125" style="zoom:50%;" />

* 作用：打印流可以实现方便、高效的打印数据到文件中去。打印流一般是指：PrintStream，PrintWriter两个类。

* 可以实现打印什么数据就是什么数据，例如打印整数97写出去就是97，打印boolean的true，写出去就是true。

```java
        //打印流
        //追加写法，只能这么干
        //PrintStream ps = new PrintStream(new FileOutputStream("FILE/src/test.txt",true));
        //不追加写法，后边不能写true，只能用上边的写法
        PrintStream ps = new PrintStream("FILE/src/test.txt");
        PrintWriter pw=new PrintWriter("FILE/src/test.txt");
        ps.println(100);//不再是这里写进去自己变成字符
        ps.println('a');
        ps.println("sdasd");
        ps.println(true);
        ps.println("我是打印流，我是啥就打印啥");
        ps.write("abc".getBytes());//因为继承自OutPutStream,可以调用write方法，但是只能写入字节
        pw.write("abc");//同上继承自Writer，只能写入字符
        ps.close();
```

## 输出语句重定向

属于打印流的一种应用，可以把输出语句的打印位置改到文件。

```java
        System.out.println("锦瑟无端五十弦");
        System.out.println("一弦一柱思华年");
        
		//改变输出语句的位置（重定向）
        PrintStream ps=new PrintStream("FILE/src/out.txt");
        System.setOut(ps);//把系统的打印流改成我们自己的打印流

        System.out.println("庄生晓梦迷蝴蝶");
        System.out.println("望帝春心托杜鹃");
```

# Properties

<img src="C:\Users\痞妖\AppData\Roaming\Typora\typora-user-images\image-20230615173359530.png" alt="image-20230615173359530" style="zoom:50%;" />

其实就是一个Map集合，但是我们一般不会当集合使用，因为HashMap更好用。



**Properties核心作用：**

* Properties代表的是一个属性文件，可以把自己对象中的键值对信息存入到一个属性文件中去。

* 属性文件：后缀是.properties结尾的文件,里面的内容都是 key=value，后续做系统配置信息的。



**Properties的作用？**

* 可以存储Properties属性集的键值对数据到属性文件中去：
  void store(Writer writer, String comments)
* 可以加载属性文件中的数据到Properties对象中来：
  void load(Reader reader)

| 构造器                                               | 说明                                                         |
| ---------------------------------------------------- | ------------------------------------------------------------ |
| void load(InputStream inStream)                      | 从输入字节流读取属性列表（键和元素对）                       |
| void  load(Reader reader)                            | 从输入字符流读取属性列表（键和元素对）                       |
| void store(OutputStream out,  String comments)       | 将此属性列表（键和元素对）写入此  Properties表中，以适合于使用 load(InputStream)方法的格式写入输出字节流 |
| void  store(Writer writer, String comments)          | 将此属性列表（键和元素对）写入此  Properties表中，以适合使用 load(Reader)方法的格式写入输出字符流 |
| public Object setProperty(String  key, String value) | 保存键值对（put）                                            |
| public String getProperty(String  key)               | 使用此属性列表中指定的键搜索属性值  (get)                    |
| public Set<String> stringPropertyNames()             | 所有键的名称的集合 (keySet())                                |

```java
        //需求：使用Properties把键值对信息存入到属性文件中去
        Properties properties = new Properties();
        properties.setProperty("admin","123456");
        properties.setProperty("dlei","456321");
        properties.setProperty("heima","654321");
        System.out.println(properties);

        //参数一：保存管道，字符输出流管道
        //参数二：保存心得
        properties.store(new FileWriter("FILE/src/out.properties"),"happy!!!");

        //加载属性文件中的键值对信息数据到属性对象propreties中去
        Properties properties2 = new Properties();
        properties2.load(new FileInputStream("FILE/src/out.properties"));
        System.out.println(properties2);

        String rs = properties2.getProperty("dlei");
```

# IO框架

```java
        //文件的复制
        IOUtils.copy(new FileInputStream("FILE/src/test.txt"),new FileOutputStream("FILE/src/test2.txt"));

        //文件复制到某个文件夹下
        FileUtils.copyFileToDirectory(new File("FILE/src/test.txt"),new File("D:/"));

        //文件夹复制到某个文件夹下
        FileUtils.copyDirectoryToDirectory(new File("D:/test"),new File("D:/out"));

        //删除功能
        FileUtils.deleteDirectory(new File("D:/out"));

        //JDK1.7自己做的一行代码完成复制的操作
        Files.copy(Path.of("D:/test"),Path.of("D:/out"));

        Files.deleteIfExists(Path.of("D:/out"));
```



